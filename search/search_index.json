{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Back of my mind","text":""},{"location":"#back-of-my-mind","title":"Back of my mind","text":"<p>Icons8: Free Icon</p> <pre><code>my-backend-docs/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md                # Home page\n\u2502   \u251c\u2500\u2500 installation.md         # Installation guide\n\u2502   \u251c\u2500\u2500 setup.md                # Setup instructions\n\u2502   \u251c\u2500\u2500 architecture.md         # System architecture overview\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # API overview\n\u2502   \u2502   \u251c\u2500\u2500 authentication.md   # Authentication &amp; Authorization\n\u2502   \u2502   \u251c\u2500\u2500 endpoints.md        # List of API endpoints\n\u2502   \u2502   \u251c\u2500\u2500 rate-limiting.md    # Rate limiting and throttling\n\u2502   \u2502   \u251c\u2500\u2500 error-handling.md   # Error handling and response codes\n\u2502   \u251c\u2500\u2500 database/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Database overview\n\u2502   \u2502   \u251c\u2500\u2500 schema.md           # Database schema\n\u2502   \u2502   \u251c\u2500\u2500 migrations.md       # Migration guide\n\u2502   \u2502   \u251c\u2500\u2500 relationships.md    # Entity relationships (ERD)\n\u2502   \u251c\u2500\u2500 testing/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Testing overview\n\u2502   \u2502   \u251c\u2500\u2500 unit-testing.md     # Unit testing guidelines\n\u2502   \u2502   \u251c\u2500\u2500 integration-testing.md  # Integration testing setup\n\u2502   \u2502   \u251c\u2500\u2500 test-coverage.md    # Test coverage report\n\u2502   \u251c\u2500\u2500 deployment/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Deployment guide\n\u2502   \u2502   \u251c\u2500\u2500 ci-cd.md            # CI/CD setup\n\u2502   \u2502   \u251c\u2500\u2500 docker.md           # Docker setup\n\u2502   \u251c\u2500\u2500 troubleshooting.md      # Common issues and solutions\n\u2502   \u251c\u2500\u2500 best-practices.md       # Backend best practices (security, scalability, etc.)\n\u2502   \u251c\u2500\u2500 glossary.md             # Glossary of terms\n\u251c\u2500\u2500 mkdocs.yml                  # MkDocs configuration file\n</code></pre>"},{"location":"#should-you-learn-nodejs-before-express","title":"Should You Learn Node.js Before Express?","text":"<p>Yes, it's recommended to learn <code>Node.js</code> first before diving into <code>Express.js</code>. Here\u2019s why:</p> <ol> <li> <p>Node.js is the foundation:</p> <ul> <li> <p>Express is a web framework built on top of Node.js, so understanding how Node works will make it much easier to understand how Express fits into the picture.</p> </li> <li> <p>Node.js provides the JavaScript runtime on the server, handling things like file I/O, HTTP requests, and event-driven programming. Express abstracts much of this functionality and makes it easier to work with, but if you don\u2019t understand the basics of Node, you might feel lost when things go wrong.</p> </li> </ul> </li> <li> <p>Understanding Node Basics: Before you jump into Express, make sure you understand:</p> <ul> <li>How to use Node.js modules (like <code>fs</code>, <code>http</code>, <code>path</code>).</li> <li>The event-driven architecture and how Node uses a single-threaded model for non-blocking I/O.</li> <li>How to create HTTP servers and handle requests and responses in pure Node.js (without Express).</li> <li>How npm (Node Package Manager) works for managing dependencies.</li> </ul> </li> <li> <p>Express Simplifies Node:</p> <ul> <li>Express is built on top of Node and provides a simplified API for handling HTTP requests, routing, middleware, and so on. It does a lot of the heavy lifting for you, making Node development easier and faster. However, if you don\u2019t know the underlying concepts of Node.js, you might not fully appreciate how Express is working under the hood.</li> </ul> </li> </ol> Suggested Learning Order <ol> <li> <p>Learn Node.js basics first:</p> <ul> <li>Understand Event Loop, callbacks, promises, and async/await.</li> <li>Learn how to create simple web servers using the built-in <code>http</code> module.</li> <li>Explore how to handle file operations, work with the file system (<code>fs</code>), and make network requests (using <code>http</code>, <code>https</code> modules).</li> </ul> </li> <li> <p>Learn Express.js:</p> <ul> <li>Once you're comfortable with Node.js, you can jump into Express. You\u2019ll see how Express simplifies the HTTP server creation process, helps with routing, middleware handling, and provides utilities for common backend tasks.</li> </ul> </li> </ol> <p>Example: Node.js vs Express</p> <p>Let\u2019s compare writing a basic web server in Node.js versus Express:</p> <p>Node.js (Barebones HTTP Server):</p> <pre><code>const http = require(\"http\");\n\nconst server = http.createServer((req, res) =&gt; {\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"text/plain\");\n  res.end(\"Hello, world!\");\n});\n\nserver.listen(3000, \"127.0.0.1\", () =&gt; {\n  console.log(\"Server running at http://127.0.0.1:3000/\");\n});\n</code></pre> <p>Express (Same Server):</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.get(\"/\", (req, res) =&gt; {\n  res.send(\"Hello, world!\");\n});\n\napp.listen(3000, () =&gt; {\n  console.log(\"Server running at http://localhost:3000\");\n});\n</code></pre> <p>With Express, you don\u2019t need to manually set up headers, status codes, or handle the routing manually. Express makes it much simpler to write server code, especially for larger applications.</p> <p>In Summary:</p> <ul> <li>Learn Node.js first: It\u2019s the foundational knowledge that will help you understand how Express works. You\u2019ll get a better grasp of the underlying JavaScript and asynchronous programming concepts.</li> <li>Learn Express afterward: Express simplifies common tasks in Node.js, like routing and middleware, and it makes backend development faster and more structured.</li> </ul>"},{"location":"api/","title":"API overview","text":""},{"location":"api/authentication/","title":"Authentication &amp; Authorization","text":""},{"location":"api/endpoints/","title":"List of API endpoints","text":""},{"location":"api/error-handling/","title":"Error handling and response codes","text":""},{"location":"api/rate-limiting/","title":"Rate limiting and throttling","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/07/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/","title":"Do You Need Grafana and Prometheus as a FastAPI Developer?","text":"","tags":["Best Practices"]},{"location":"blog/2025/07/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#do-you-need-grafana-and-prometheus-as-a-fastapi-developer","title":"Do You Need Grafana and Prometheus as a FastAPI Developer?","text":"<p>As a FastAPI developer, you're probably focused on building fast, reliable APIs. But as your application grows, you\u2019ll start asking deeper questions like:</p> <ul> <li>How do I know my app is healthy?</li> <li>What happens if something fails in production?</li> <li>Should I use observability tools like Grafana and Prometheus?</li> </ul> <p>Let\u2019s explore this with clarity \u2014 and without the hype.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#first-what-do-grafana-and-prometheus-actually-do","title":"\ud83e\udd14 First, What Do Grafana and Prometheus Actually Do?","text":"<ul> <li>Prometheus is a monitoring system that collects metrics from your app (like request rates, latency, CPU usage).</li> <li>Grafana is a visualization tool that builds dashboards on top of those metrics, often from Prometheus.</li> </ul> <p>Together, they form a powerful observability stack \u2014 but they also add complexity.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#should-you-use-them-in-your-fastapi-project","title":"\ud83d\udea6 Should You Use Them in Your FastAPI Project?","text":"<p>Here\u2019s a practical rule of thumb:</p> Project Type Use Grafana + Prometheus? \ud83d\udd39 Personal / hobby project \u274c No \ud83d\udd39 MVP or early-stage app \u274c Not yet \ud83d\udd38 Production API with users \u26a0\ufe0f Maybe \ud83d\udd38 SaaS / scalable backend \u2705 Yes \ud83d\udd38 Microservices / DevOps team \u2705 Absolutely","tags":["Best Practices"]},{"location":"blog/2025/07/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#when-it-makes-sense","title":"\u2705 When It Makes Sense","text":"<p>Use Grafana + Prometheus when:</p> <ul> <li>You deploy to production</li> <li>You care about uptime, latency, or error rates</li> <li>You want to alert on failures or slow endpoints</li> <li>You have multiple services or infrastructure to monitor</li> </ul> <p>Example: Your API starts timing out randomly, but logs don\u2019t show anything. Metrics from Prometheus can reveal CPU spikes or slow queries in real time.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#when-its-overkill","title":"\u274c When It\u2019s Overkill","text":"<p>Skip Grafana + Prometheus if:</p> <ul> <li>You're building locally or just learning</li> <li>Your system is simple and has no uptime requirement</li> <li>You just need basic logging or debugging</li> </ul> <p>Instead, stick to:</p> <ul> <li><code>print()</code> or Python <code>logging</code></li> <li>FastAPI logs from Uvicorn</li> <li>Error monitoring (e.g. Sentry)</li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/07/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#a-lightweight-middle-ground","title":"\ud83d\udee0\ufe0f A Lightweight Middle Ground","text":"<p>You don\u2019t need the full stack to get started. Try this:</p> <ol> <li>Install the Prometheus FastAPI middleware:</li> </ol> <pre><code>pip install prometheus-fastapi-instrumentator\n</code></pre> <ol> <li>Add it to your app:</li> </ol> <pre><code>from fastapi import FastAPI\nfrom prometheus_fastapi_instrumentator import Instrumentator\n\napp = FastAPI()\nInstrumentator().instrument(app).expose(app)\n</code></pre> <ol> <li>Run Prometheus to scrape your app at <code>/metrics</code>.</li> <li>Optionally visualize it in Grafana.</li> </ol> <p>It\u2019s simple and gives you visibility without heavy setup.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#final-thought","title":"\ud83e\udde0 Final Thought","text":"<p>Don\u2019t adopt tools blindly. Prometheus and Grafana are not \"must-haves\" \u2014 they\u2019re \"power-tools\" for when monitoring becomes a problem to solve.</p> <p>Before integrating them, ask:</p> <p>What failure am I trying to prevent or detect?</p> <p>Only when the answer matters to your system\u2019s success, should you bring them in.</p> <p>\ud83d\udccc TL;DR</p> <ul> <li>\ud83d\udeab Don\u2019t use Grafana/Prometheus just because they\u2019re popular.</li> <li>\u2705 Use them if you need deep visibility into a production system.</li> <li>\u2696\ufe0f For small apps, consider lightweight metrics + logging first.</li> </ul> <p>Need help setting up minimal monitoring for your FastAPI app? Check out this minimal observability stack (Coming soon).</p>","tags":["Best Practices"]},{"location":"blog/2025/07/02/thinking-like-a-systems-designer/","title":"Thinking Like a Systems Designer","text":"","tags":["Best Practices"]},{"location":"blog/2025/07/02/thinking-like-a-systems-designer/#thinking-like-a-systems-designer","title":"Thinking Like a Systems Designer","text":"<p>Excellent \u2014 you're thinking like a real systems designer now.</p> <p>In the world of modern infrastructure and observability, it's easy to get caught up in shiny tools and industry trends. Prometheus, Loki, Tempo, Grafana \u2014 these names dominate the DevOps and SRE conversation. They\u2019re powerful, yes. But ask yourself:</p> <p>Why are you using them?</p> <p>Too often, teams adopt these tools because they\u2019re the standard, not because they\u2019re the solution.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/02/thinking-like-a-systems-designer/#start-with-the-problem-not-the-tool","title":"Start With the Problem, Not the Tool","text":"<p>A real systems designer doesn\u2019t start with tools. They start with the problem.</p> <ul> <li>What are we trying to observe?</li> <li>What kind of failures do we care about?</li> <li>How fast do we need to detect anomalies?</li> <li>Who needs to be alerted, and how actionable are those alerts?</li> </ul> <p>Until you can clearly articulate these, the choice of stack is secondary.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/02/thinking-like-a-systems-designer/#a-tool-is-only-as-good-as-the-use-case-it-solves","title":"A Tool is Only as Good as the Use Case It Solves","text":"<p>Consider this scenario:</p> <p>Your team sets up Grafana dashboards, alerts via Prometheus, tracing via Tempo\u2026 but nobody uses them. Alerts are noisy. Dashboards are rarely visited. Why? Because the why was never defined.</p> <p>Just because a stack is popular doesn't mean it's what your system or team needs.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/02/thinking-like-a-systems-designer/#shift-the-mindset","title":"Shift the Mindset","text":"<p>Here's how to shift from being a \"tool chaser\" to a real systems thinker:</p> <ol> <li>Define the pain clearly \u2014 \u201cWe miss incidents in staging,\u201d or \u201cWe get flooded with alerts during deploys.\u201d</li> <li>Map out the observability needs \u2014 Do you need logs? Metrics? Traces? Where is the blind spot?</li> <li>Select minimal tools to start \u2014 Tools should serve your insights, not create work.</li> <li>Evolve based on gaps, not trends \u2014 Only introduce new tools when your current stack can\u2019t handle a growing need.</li> </ol>","tags":["Best Practices"]},{"location":"blog/2025/07/02/thinking-like-a-systems-designer/#final-thought","title":"Final Thought","text":"<p>Systems design is not about using industry-standard tools. It's about building systems that are resilient, observable, and understandable.</p> <p>Tools come and go. Principles last.</p> <p>So the next time someone says, \u201cLet\u2019s use Prometheus,\u201d ask instead:</p> <p>\ud83d\udc49 \u201cWhat are we trying to measure, and why?\u201d</p> <p>\ud83e\udde0 Think like a systems designer. Solve problems. Then pick tools.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/","title":"\ud83d\udd0d Observability: Focus on the Problems, Not Just the Tools","text":"","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/#observability-focus-on-the-problems-not-just-the-tools","title":"\ud83d\udd0d Observability: Focus on the Problems, Not Just the Tools","text":"<p>Too many teams adopt Prometheus, Loki, Tempo, and Grafana because they\u2019re \u201cstandard.\u201d But real observability is about solving problems \u2014 not collecting data.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/#the-real-question","title":"\ud83e\udded The Real Question","text":"<p>When something goes wrong in production, you don\u2019t ask:</p> <p>\u201cWhich dashboard looks coolest?\u201d</p> <p>You ask:</p> <ul> <li>\u201cWhy is my FastAPI app slow right now?\u201d</li> <li>\u201cWhat caused all these 500 errors?\u201d</li> <li>\u201cIs our new deploy breaking something?\u201d</li> </ul> <p>If your tools can't help answer those questions quickly, you don't have observability \u2014 you have monitoring noise.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/#problem-first-thinking","title":"\ud83c\udfaf Problem-First Thinking","text":"<p>Let\u2019s flip the narrative. Instead of documenting tools like this:</p> <ul> <li>Prometheus: for metrics</li> <li>Loki: for logs</li> <li>Tempo: for traces</li> <li>Grafana: to visualize everything</li> </ul> <p>Try this instead:</p> \u2753 Problem \u2705 Solution \ud83d\udee0 Tool API is slow, but why? Show end-to-end request trace Tempo Requests are failing suddenly Find logs with errors around the spike Loki Need to alert on high error rates Alert when metrics exceed thresholds Prometheus Want everything in one place Correlate metrics, logs, traces Grafana","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/#stack-architecture-reframed","title":"\ud83e\udde0 Stack Architecture \u2014 Reframed","text":"","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/#traditional-view","title":"Traditional View:","text":"<p>A diagram showing all tools wired together.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/#problem-focused-view","title":"Problem-Focused View:","text":"<ul> <li> <p>\ud83d\udd27 Need: Know when something breaks   \u2192 Use Prometheus for metrics + alerts</p> </li> <li> <p>\ud83d\udd0d Need: Understand what broke and why   \u2192 Use Loki for log context + errors</p> </li> <li> <p>\u23f1\ufe0f Need: Track what happened during a request   \u2192 Use Tempo and OpenTelemetry for tracing</p> </li> <li> <p>\ud83d\udcca Need: Correlate and visualize everything   \u2192 Use Grafana as the central interface</p> </li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/#real-example-api-latency-spike","title":"\ud83d\udee0 Real Example: API Latency Spike","text":"<p>You see a latency spike on <code>/api/orders</code>.</p> <p>Here\u2019s how the stack helps:</p> <ol> <li>Prometheus shows the spike in response time</li> <li>Grafana alert fires, and you click the dashboard</li> <li>You follow a Tempo trace from that request</li> <li>Trace shows DB query took 1.2s \u2014 that\u2019s the bottleneck</li> <li>You jump into Loki logs by trace ID</li> <li>Error message confirms: <code>Missing index on orders.created_at</code></li> </ol> <p>\ud83d\udd01 Metrics \u2192 Trace \u2192 Logs \u2192 Resolution All in one flow, from a single alert.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/03/-observability-focus-on-the-problems-not-just-the-tools/#takeaway","title":"\u2705 Takeaway","text":"<p>Don\u2019t build observability for the sake of having dashboards.</p> <p>Build it so when your app breaks at 2:14 AM, you know:</p> <ul> <li>What broke</li> <li>Why it broke</li> <li>Where to fix it</li> </ul> <p>That's what Prometheus, Loki, Tempo, and Grafana are for \u2014 when used right.</p> <p>\ud83d\udcda Learn More:</p>","tags":["Best Practices"]},{"location":"core/architecture/","title":"Architecture","text":""},{"location":"core/architecture/#system-architecture-overview","title":"System Architecture Overview","text":"<p>This section outlines the high-level architecture of the backend system. The backend is designed to be scalable, maintainable, and secure, supporting a variety of use cases while ensuring flexibility and performance.</p>"},{"location":"core/architecture/#architecture-diagram","title":"Architecture Diagram","text":"<p>Note: Replace with your actual architecture diagram.</p>"},{"location":"core/architecture/#components","title":"Components","text":""},{"location":"core/architecture/#1-client-frontend","title":"1. Client (Frontend)","text":"<p>The client-side (browser, mobile app, or other service) communicates with the backend via a RESTful API or GraphQL (depending on the use case). The client handles the user interface and interaction, sending requests to the backend for data and receiving responses to update the UI.</p>"},{"location":"core/architecture/#2-api-gateway","title":"2. API Gateway","text":"<p>The API Gateway acts as the entry point for all incoming requests from the client. It handles routing, authentication, rate-limiting, and sometimes caching of requests to backend services. It may also handle load balancing if multiple backend services are deployed.</p> <p>Responsibilities:</p> <ul> <li>Authenticate and authorize requests.</li> <li>Route requests to the appropriate backend service.</li> <li>Perform rate-limiting and security checks.</li> </ul>"},{"location":"core/architecture/#3-authentication-authorization-service","title":"3. Authentication &amp; Authorization Service","text":"<p>This service manages user authentication, session management, and authorization. It verifies the identity of users and generates JWT tokens or OAuth tokens for secure communication between the client and backend.</p> <p>Responsibilities:</p> <ul> <li>Authenticate users (login, logout).</li> <li>Issue and verify tokens (JWT, OAuth).</li> <li>Provide user roles and permissions.</li> </ul>"},{"location":"core/architecture/#4-core-backend-services","title":"4. Core Backend Services","text":"<p>These are the core services that handle business logic, data processing, and serve API requests. The backend is typically divided into different services, each responsible for a specific set of operations (e.g., user management, product management, payment processing, etc.).</p> <p>Service Layer:</p> <ul> <li>Each backend service can be either monolithic or microservices-based.</li> <li>Microservices may interact with each other via REST or gRPC.</li> <li>The services are stateless and can be scaled independently.</li> </ul>"},{"location":"core/architecture/#5-database-layer","title":"5. Database Layer","text":"<p>The database stores all persistent data, such as user information, transactional data, and application state. The choice of database may vary depending on the project needs.</p> <p>Relational Database (SQL) Example:</p> <ul> <li>PostgreSQL, MySQL, or similar.</li> <li>Stores structured data with relationships between entities (e.g., users, products).</li> </ul> <p>NoSQL Database Example:</p> <ul> <li>MongoDB, Redis, etc., for flexible schema or caching purposes.</li> </ul> <p>Responsibilities:</p> <ul> <li>Handle CRUD operations for entities.</li> <li>Manage relationships and schema consistency.</li> <li>Ensure data integrity and durability.</li> </ul>"},{"location":"core/architecture/#6-caching-layer","title":"6. Caching Layer","text":"<p>Caching is used to store frequently accessed data in-memory to reduce database load and speed up response times. Common tools include Redis or Memcached.</p> <p>Responsibilities:</p> <ul> <li>Cache common query results (e.g., product data, user sessions).</li> <li>Improve read performance by reducing database load.</li> </ul>"},{"location":"core/architecture/#7-queuemessage-broker","title":"7. Queue/Message Broker","text":"<p>In a microservices or distributed architecture, a message queue or broker (e.g., RabbitMQ, Kafka) facilitates asynchronous communication between services, decoupling the services and enabling event-driven architecture.</p> <p>Responsibilities:</p> <ul> <li>Process long-running tasks asynchronously (e.g., email notifications, image processing).</li> <li>Ensure services are loosely coupled and resilient.</li> </ul>"},{"location":"core/architecture/#8-monitoring-and-logging","title":"8. Monitoring and Logging","text":"<p>Monitoring tools (e.g., Prometheus, Grafana) and centralized logging systems (e.g., ELK Stack, Splunk) are essential for tracking the performance, availability, and errors in the backend system.</p> <p>Responsibilities:</p> <ul> <li>Collect metrics on request latency, error rates, and system health.</li> <li>Aggregate logs for debugging and auditing.</li> <li>Send alerts for abnormal system behavior.</li> </ul>"},{"location":"core/architecture/#9-cicd-pipeline","title":"9. CI/CD Pipeline","text":"<p>Continuous Integration and Continuous Deployment (CI/CD) automates the build, testing, and deployment process. Tools like Jenkins, GitLab CI, or GitHub Actions ensure that code changes are automatically tested and deployed to production with minimal human intervention.</p> <p>Responsibilities:</p> <ul> <li>Automate code quality checks (linting, unit tests).</li> <li>Deploy to staging and production environments.</li> <li>Rollback deployments if issues occur.</li> </ul>"},{"location":"core/architecture/#deployment-architecture","title":"Deployment Architecture","text":""},{"location":"core/architecture/#1-containerization-docker","title":"1. Containerization (Docker)","text":"<p>The backend services are containerized using Docker to ensure consistent environments across development, staging, and production. This also simplifies scaling and deployment.</p>"},{"location":"core/architecture/#2-orchestration-kubernetes","title":"2. Orchestration (Kubernetes)","text":"<p>Kubernetes is used for orchestrating and managing containerized services. It provides features like auto-scaling, self-healing, and load balancing.</p>"},{"location":"core/architecture/#3-cloud-infrastructure-aws-gcp-azure","title":"3. Cloud Infrastructure (AWS, GCP, Azure)","text":"<p>The backend is deployed on cloud infrastructure to provide scalability, redundancy, and high availability. The cloud provider may offer additional services like managed databases, caching, and message queues.</p> <p>Responsibilities:</p> <ul> <li>Automate scaling based on traffic load.</li> <li>Ensure fault tolerance and disaster recovery.</li> </ul>"},{"location":"core/architecture/#summary","title":"Summary","text":"<p>The backend architecture is designed for scalability, resilience, and performance. By splitting the system into manageable components and services, we ensure that each part of the system can be developed, tested, and deployed independently. This architecture is adaptable to various backend frameworks and technologies, and it supports a wide range of client applications.</p> <p>For detailed specifications of each component, see the corresponding documentation sections:</p> <ul> <li>API Documentation</li> <li>Database Schema</li> <li>Deployment Guide</li> </ul>"},{"location":"core/bff/intro/","title":"Intro","text":"<p>The Backends for Frontends (BFF) pattern is an architectural pattern that involves creating a separate backend service for each frontend application. This pattern is often used in microservices architectures, where each service is responsible for a specific function.</p> <p></p> <p></p>"},{"location":"core/bff/intro/#what-is-backend-for-frontend-bff","title":"What is Backend for Frontend (BFF)?","text":"<p>Backend for Frontend (BFF) is a design pattern that involves creating a dedicated backend service tailored specifically for a particular frontend application (like a web or mobile app). This approach helps in optimizing the communication between the frontend and backend by providing a layer that is specifically designed to serve the needs of the frontend, making it easier to manage and improve performance.</p>"},{"location":"core/bff/intro/#overview","title":"Overview","text":"<p>Backend for Frontend (BFF) is designed to create a dedicated backend layer tailored specifically for individual frontend applications. It serves to optimize communication, improve performance, and streamline development by providing APIs that are custom-built to meet the specific needs of each frontend.</p>"},{"location":"core/bff/intro/#key-features-of-bff","title":"Key Features of BFF","text":"<ol> <li>Tailored API: Each frontend (web, mobile, etc.) can have its own backend that serves only the data and functionality it needs.</li> <li>Reduced Over-fetching: By designing the API specifically for the frontend, you can avoid sending unnecessary data, reducing payload sizes.</li> <li>Simplified Logic: It allows for frontend-specific logic to reside in the backend, keeping the frontend code cleaner and more focused on presentation.</li> <li>Easier Adaptation: Changes in the frontend can often be accommodated in the BFF without affecting the overall backend architecture.</li> </ol>"},{"location":"core/bff/intro/#scenario","title":"Scenario","text":"With BFFWithout BFFSummary <p>Suppose you have two different frontend applications: a web app and a mobile app. Each of these apps requires different data formats and structures from the backend.</p> <ul> <li>Web App: Needs detailed information, including user profiles, order histories, and recommendations.</li> <li>Mobile App: Needs summarized data to save bandwidth, focusing only on essential information like user profiles and recent orders.</li> </ul> BFF Implementation <p>BFF Layer:</p> <ul> <li> <p>Web BFF:</p> <ul> <li>API Endpoint: <code>/api/web/user-profile</code></li> <li>Returns detailed user information, including nested objects.</li> </ul> </li> <li> <p>Mobile BFF:</p> <ul> <li>API Endpoint: <code>/api/mobile/user-profile</code></li> <li>Returns a simplified version of the user profile with only essential fields.</li> </ul> </li> </ul> <p>Benefits:</p> <ul> <li>Tailored Responses: Each frontend gets exactly what it needs without over-fetching or under-fetching data.</li> <li>Decoupled Development: Frontend teams can work independently from backend teams since the BFF layer abstracts the backend complexities.</li> <li>Optimized Performance: By reducing payload sizes for the mobile app, you improve loading times and user experience.</li> </ul> <p>In a traditional setup, you might have a single backend service that serves both the web and mobile apps.</p> <ul> <li> <p>Single API Endpoint: <code>/api/user-profile</code></p> <ul> <li>Returns all user data regardless of the frontend requesting it, including detailed information that the mobile app doesn't need.</li> </ul> </li> </ul> Drawbacks: <ul> <li>Over-fetching: The mobile app receives more data than it needs, leading to larger payloads and slower response times.</li> <li>Inflexibility: Any changes required for one frontend can inadvertently affect the other, making development less agile.</li> <li>Complexity: Frontend developers may need to implement additional logic to filter and process unnecessary data, adding to their workload.</li> </ul> <p>Using a BFF allows you to tailor backend services specifically for different frontend applications, optimizing data delivery, improving performance, and simplifying development. In contrast, a traditional single-backend approach can lead to inefficiencies and complexities as frontends evolve.</p>"},{"location":"core/bff/intro/#implementation-in-drf","title":"Implementation in drf","text":""},{"location":"core/bff/intro/#is-bff-a-microservice","title":"Is BFF a Microservice?","text":"<p>Yes, the Backend For Frontend pattern is one of several types of microservice architecture patterns.</p> <p>Each BFF service is considered a microservice that serves as a connector between frontend and backend development.</p>"},{"location":"core/bff/intro/#reference","title":"Reference","text":"<ul> <li>Backend for Frontend: Understanding the Pattern to Unlock Its Power</li> <li>Backends for Frontends (BFF) Pattern: Architectural Patterns</li> <li>Why \u201cBackend For Frontend\u201d Application Architecture?</li> <li>Backends For Frontends \u2014 My Take</li> </ul>"},{"location":"core/bff/question/","title":"Question","text":""},{"location":"core/bff/question/#question","title":"Question","text":"<p>What is required to implement a Backend for Frontend (BFF) architecture in Django with Django REST Framework (DRF)?</p> <p>To implement a BFF architecture in Django and DRF, you generally need to focus on the following key components:</p> <ol> <li> <p>Custom Serializers:</p> <ul> <li>You will need to create different serializers for each frontend application (e.g., web and mobile) to tailor the data structure according to their specific needs.</li> </ul> </li> <li> <p>Viewsets:</p> <ul> <li>Create separate viewsets for each frontend, using the custom serializers to handle requests and responses appropriately.</li> </ul> </li> <li> <p>URLs:</p> <ul> <li>Set up distinct URL routes for each BFF endpoint, ensuring that each frontend can access its corresponding API.</li> </ul> </li> <li> <p>Data Models (if applicable):</p> <ul> <li>Your data models may remain the same, but the way you serve them will differ based on the serializers and viewsets you create.</li> </ul> </li> <li> <p>Authentication and Permissions (if needed):</p> <ul> <li>You may also want to implement different authentication or permission schemes based on the frontend requirements.</li> </ul> </li> </ol> <p>Summary</p> <p>While customizing serializers is a significant part of implementing a BFF, it\u2019s not the only step. You also need to create dedicated viewsets and URL configurations to ensure each frontend receives the data in the format it requires.</p>"},{"location":"core/bff/question/#step-by-step-example","title":"Step-by-Step Example","text":"Basic Example <ol> <li> <p>Set Up Your Django Project</p> <p>First, create a new Django project and an app:</p> <pre><code>django-admin startproject my_bff\ncd my_bff\ndjango-admin startapp user\n</code></pre> </li> <li> <p>Install Django REST Framework</p> <p>Install DRF:</p> <pre><code>pip install djangorestframework\n</code></pre> <p>Add <code>'rest_framework'</code> and your app (<code>'user'</code>) to <code>INSTALLED_APPS</code> in <code>settings.py</code>:</p> <pre><code># my_bff/settings.py\n\nINSTALLED_APPS = [\n    ...\n    'rest_framework',\n    'user',\n]\n</code></pre> </li> <li> <p>Create the User Model</p> <p>Define a simple User model in <code>models.py</code>:</p> <pre><code># user/models.py\n\nfrom django.db import models\n\nclass User(models.Model):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    phone = models.CharField(max_length=15)\n    street = models.CharField(max_length=255)\n    city = models.CharField(max_length=100)\n    zipcode = models.CharField(max_length=10)\n    newsletter = models.BooleanField(default=False)\n    notifications = models.BooleanField(default=False)\n\n    def __str__(self):\n        return self.username\n</code></pre> <p>Run the migrations to create the User table:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> </li> <li> <p>Create Serializers</p> <p>Create serializers for the User model in <code>serializers.py</code>:</p> <pre><code># user/serializers.py\n\nfrom rest_framework import serializers\nfrom .models import User\n\nclass UserProfileWebSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email', 'phone', 'street', 'city', 'zipcode', 'newsletter', 'notifications']\n\nclass UserProfileMobileSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email']\n</code></pre> </li> <li> <p>Create Viewsets</p> <p>Define viewsets for the different BFFs in <code>views.py</code>:</p> <pre><code># user/views.py\n\nfrom rest_framework import viewsets\nfrom .models import User\nfrom .serializers import UserProfileWebSerializer, UserProfileMobileSerializer\n\nclass UserProfileWebViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserProfileWebSerializer\n\nclass UserProfileMobileViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserProfileMobileSerializer\n</code></pre> </li> <li> <p>Configure URLs</p> <p>Set up URLs for the two different BFFs in <code>urls.py</code>:</p> <pre><code># user/urls.py\n\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import UserProfileWebViewSet, UserProfileMobileViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'web/user-profile', UserProfileWebViewSet, basename='user-web')\nrouter.register(r'mobile/user-profile', UserProfileMobileViewSet, basename='user-mobile')\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre> <p>Include the user app URLs in the main project <code>urls.py</code>:</p> <pre><code># my_bff/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('api/', include('user.urls')),\n]\n</code></pre> </li> <li> <p>Test the BFF APIs</p> <p>Run your Django server:</p> <pre><code>python manage.py runserver\n</code></pre> </li> </ol>"},{"location":"core/bff/question/#endpoint","title":"Endpoint","text":"<p>Now, you can test the endpoints using a tool like <code>Postman</code> or <code>curl</code>.</p> 1. Web App Endpoint:2. Mobile App Endpoint: <ul> <li>URL: <code>http://localhost:8000/api/web/user-profile/</code></li> <li> <p>Response Example:</p> <pre><code>{\n    \"id\": 1,\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\",\n    \"phone\": \"123-456-7890\",\n    \"street\": \"123 Elm St\",\n    \"city\": \"Somewhere\",\n    \"zipcode\": \"12345\",\n    \"newsletter\": true,\n    \"notifications\": false\n}\n</code></pre> </li> </ul> <ul> <li>URL: <code>http://localhost:8000/api/mobile/user-profile/</code></li> <li> <p>Response Example:</p> <pre><code>{\n    \"id\": 1,\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\"\n}\n</code></pre> </li> </ul> Benefits of Using BFF <ol> <li> <p>Tailored Responses:</p> <ul> <li>The web app receives all necessary details, while the mobile app only gets the crucial information it needs.</li> </ul> </li> <li> <p>Reduced Payload:</p> <ul> <li>The mobile app's response is smaller, improving load times and performance.</li> </ul> </li> <li> <p>Decoupled Development:</p> <ul> <li>Frontend teams can make changes to their BFFs independently without affecting the other frontend.</li> </ul> </li> </ol> <p>Conclusion</p> <p>In this example, we implemented a BFF architecture using Django and Django REST Framework. We created two separate APIs tailored for different frontends (web and mobile), showcasing how to customize serializers, viewsets, and URLs to meet the specific needs of each frontend application. This approach optimizes data delivery and enhances performance, making it a great architectural choice.</p>"},{"location":"database/","title":"Overview","text":"<p>api</p>"},{"location":"database/migrations/","title":"Migration guide","text":""},{"location":"database/relationships/","title":"Entity relationships (ERD)","text":""},{"location":"database/schema/","title":"Database schema","text":""},{"location":"deployment/","title":"Overview","text":"<p>api</p>"},{"location":"deployment/ci-cd/","title":"CI/CD setup","text":""},{"location":"deployment/docker/","title":"Docker setup","text":""},{"location":"framework/nodejs/guide/","title":"Guide","text":""},{"location":"framework/nodejs/guide/#guide","title":"Guide","text":""},{"location":"framework/nodejs/guide/#tech-stack","title":"Tech Stack","text":"<p>For this simple CRUD API, the recommended tech stack is:</p> <ol> <li> <p>Backend Framework: Node.js with Express.js</p> <p>Lightweight and easy to use for building REST APIs.</p> </li> <li> <p>Database: PostgreSQL</p> <p>Structured and relational, ideal for handling amount and date data.</p> </li> <li> <p>ORM: Sequelize</p> <p>Simplifies database interactions with PostgreSQL.</p> </li> <li> <p>ontainerization: Docker</p> <p>Ensures portability and ease of deployment.</p> </li> </ol>"},{"location":"framework/nodejs/guide/#folder-structure-backend-only","title":"Folder Structure (Backend Only)","text":"<p>In this setup, you will have a backend-only project that exposes the API, and the React frontend (which will be in a separate project) will consume these APIs.</p> <pre><code>/my-app\n  /server                  # Backend (Node.js with Express and MongoDB)\n    /controllers           # API endpoint controllers\n    /models                # Mongoose models\n    /routes                # API routes\n    /config                # Database configuration\n    server.js              # Main entry point of the backend server\n    package.json           # Backend dependencies\n    .env                   # Environment variables (e.g., MongoDB URI)\n  README.md                # Project description\n</code></pre> <pre><code>- src/\n  - models/\n    - record.model.js\n  - routes/\n    - record.routes.js\n  - controllers/\n    - record.controller.js\n  - config/\n    - db.config.js\n  - server.js\n- Dockerfile\n- docker-compose.yml\n</code></pre>"},{"location":"framework/nodejs/guide/#backend-setup","title":"Backend Setup","text":""},{"location":"framework/nodejs/guide/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Go to the backend directory (<code>/server</code>) and initialize the project with:</p> <pre><code>cd /server\nnpm init -y\nnpm install express mongoose cors dotenv\n</code></pre>"},{"location":"framework/nodejs/guide/#2-folder-structure-and-backend-code","title":"2. Folder Structure and Backend Code","text":"<ul> <li>server.js: Entry point for the Express server.</li> <li>controllers/recordController.js: Controller logic for CRUD operations.</li> <li>models/Record.js: Mongoose schema for records.</li> <li>routes/recordRoutes.js: Define API routes.</li> </ul>"},{"location":"framework/nodejs/guide/#7-running-the-backend","title":"7. Running the Backend","text":"<pre><code>node server.js\n</code></pre>"},{"location":"framework/nodejs/guide/#code","title":"CODE","text":"<ol> <li> <p>Database Configuration (<code>src/config/db.config.js</code>)</p> <pre><code>const { Sequelize } = require(\"sequelize\");\n\nconst sequelize = new Sequelize(\"crud_db\", \"postgres\", \"password\", {\n  host: \"localhost\",\n  dialect: \"postgres\",\n});\n\nmodule.exports = sequelize;\n</code></pre> </li> <li> <p>Model Definition (<code>src/models/record.model.js</code>)</p> <pre><code>const { DataTypes } = require(\"sequelize\");\nconst sequelize = require(\"../config/db.config\");\n\nconst Record = sequelize.define(\"Record\", {\n  amount: {\n    type: DataTypes.FLOAT,\n    allowNull: false,\n  },\n  date: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n});\n\nmodule.exports = Record;\n</code></pre> </li> <li> <p>Controller (<code>src/controllers/record.controller.js</code>)</p> <pre><code>const Record = require(\"../models/record.model\");\n\n// Create a new record\nexports.createRecord = async (req, res) =&gt; {\n  try {\n    const { amount, date } = req.body;\n    const record = await Record.create({ amount, date });\n    res.status(201).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Get all records\nexports.getRecords = async (req, res) =&gt; {\n  try {\n    const records = await Record.findAll();\n    res.status(200).json(records);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Get a single record by ID\nexports.getRecordById = async (req, res) =&gt; {\n  try {\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n    res.status(200).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Update a record by ID\nexports.updateRecord = async (req, res) =&gt; {\n  try {\n    const { amount, date } = req.body;\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n\n    record.amount = amount;\n    record.date = date;\n    await record.save();\n\n    res.status(200).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Delete a record by ID\nexports.deleteRecord = async (req, res) =&gt; {\n  try {\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n\n    await record.destroy();\n\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n</code></pre> </li> <li> <p>Routes (<code>src/routes/record.routes.js</code>)</p> <pre><code>const express = require(\"express\");\nconst router = express.Router();\nconst controller = require(\"../controllers/record.controller\");\n\nrouter.post(\"/\", controller.createRecord);\nrouter.get(\"/\", controller.getRecords);\nrouter.get(\"/:id\", controller.getRecordById);\nrouter.put(\"/:id\", controller.updateRecord);\nrouter.delete(\"/:id\", controller.deleteRecord);\n\nmodule.exports = router;\n</code></pre> </li> <li> <p>Server Setup (<code>src/server.js</code>)</p> <pre><code>const express = require(\"express\");\nconst sequelize = require(\"./config/db.config\");\nconst recordRoutes = require(\"./routes/record.routes\");\n\nconst app = express();\napp.use(express.json());\n\n// Routes\napp.use(\"/api/records\", recordRoutes);\n\n// Start server and connect to DB\nsequelize\n  .sync()\n  .then(() =&gt; {\n    console.log(\"Database connected!\");\n    app.listen(3000, () =&gt; console.log(\"Server running on port 3000\"));\n  })\n  .catch((err) =&gt; console.error(\"Database connection failed:\", err));\n</code></pre> </li> <li> <p>Dockerfile</p> <pre><code>FROM node:16\n\nWORKDIR /app\n\nCOPY package.json package-lock.json ./\nRUN npm install\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [\"node\", \"src/server.js\"]\n</code></pre> </li> <li> <p>Docker Compose (<code>docker-compose.yml</code>)</p> <pre><code>version: \"3.8\"\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - db\n\n  db:\n    image: postgres:latest\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: crud_db\n    ports:\n      - \"5432:5432\"\n</code></pre> </li> </ol> How to Run <ol> <li> <p>Build and start the services:</p> <pre><code>docker-compose up --build\n</code></pre> </li> <li> <p>Access the API at <code>http://localhost:3000/api/records</code>.</p> </li> </ol> <p>This setup provides a fully functional CRUD API using Node.js, Express, PostgreSQL, Sequelize, and Docker</p>"},{"location":"framework/nodejs/guide/#extra","title":"Extra","text":""},{"location":"framework/nodejs/guide/#database","title":"DATABASE","text":"<pre><code>CREATE DATABASE testdb;\n\\list\n# or\n\\l\n# is same\n</code></pre>"},{"location":"framework/nodejs/guide/#listing-users-in-postgresql","title":"Listing users in PostgreSQL","text":"<p>Using the <code>\\du</code> Command</p> <ul> <li>The simplest way to list all users is by using the <code>\\du</code> command in the psql terminal.</li> <li>This will show a list of all roles in the database, including users, their attributes (such as superuser status), and their assigned roles.</li> </ul> <pre><code>\\du\n</code></pre> <p>This will display a table with the following columns:</p> <ul> <li>Role Name: The name of the user or role.</li> <li>Attributes: Whether the role is a superuser, can create databases, or has login privileges.</li> <li>Member Of: Any other roles this user belongs to.</li> </ul>"},{"location":"framework/nodejs/guide/#list-of-roles","title":"List of Roles","text":"Role name Attributes Member of postgres Superuser, Create role, Create DB, Replication, Bypass RLS {} bishow Create DB {} myuser Create DB {postgres}"},{"location":"framework/nodejs/guide/#to-check-if-user-has-password-or-not","title":"To Check if user has password or not","text":"<p>To check if a PostgreSQL user (like <code>bishow</code>) has a password set, you can query the pg_shadow system catalog table, which stores user information including the password hash (if set).</p> <ol> <li> <p>Querying the <code>pg_shadow</code> Table</p> <p>The <code>pg_shadow</code> table contains user information, including password data. To check if the user <code>bishow</code> has a password set, you can run the following query:</p> <pre><code>SELECT usename, passwd FROM pg_shadow WHERE usename = 'bishow';\n</code></pre> <ul> <li><code>usename</code>: The username.</li> <li><code>passwd</code>: The hashed password (if set) or an empty string if no password is set.</li> </ul> </li> </ol>"},{"location":"framework/nodejs/guide/#switch-user-to-login","title":"Switch User to Login","text":"<p>When you run the command:</p> <pre><code>sudo -u postgres psql\n</code></pre> <p>You are switching to the <code>postgres</code> user and logging into the PostgreSQL database as the <code>postgres</code> user (which is typically the superuser for PostgreSQL). Here's a breakdown:</p> <ul> <li> <p><code>sudo -u postgres</code>: This part of the command tells <code>sudo</code> to run the following command (<code>psql</code>) as the <code>postgres</code> user, which is usually the default superuser in PostgreSQL.</p> </li> <li> <p><code>psql</code>: This is the PostgreSQL interactive terminal that connects to the database.</p> </li> </ul> <p>Once you're inside the psql terminal, you'll be logged in as the <code>postgres</code> PostgreSQL user, not as your system's current user (e.g., <code>bishow</code> or any other user you might have logged in as on the operating system).</p> <p>To verify this inside the PostgreSQL terminal, you can run the following SQL command:</p> <pre><code>SELECT current_user;\n</code></pre> <p>This will return the PostgreSQL user you're currently logged in as.</p> <pre><code>postgres=# SELECT current_user;\n current_user\n--------------\n postgres\n(1 row)\n</code></pre> <p>In this example, the current PostgreSQL user is <code>postgres</code>.</p>"},{"location":"framework/nodejs/history/","title":"History","text":"<p>Node.js was initially developed by Ryan Dahl. He took the V8 JavaScript engine from Google\u2019s Chrome browser, added some APIs, wrapped it in an event loop, and launched it as an open-source product on Linux and macOS in 2009. The Windows edition arrived in 2011.</p> <p>The Node Package Manager (npm) was introduced in <code>2010</code>. It allowed developers to use code modules published by others in their own projects. There was no official ECMAScript module standard at the time, so Node.js and npm adopted CommonJS.</p> <p><code>Node.js: Novice to Ninja by SitePoint</code></p> <p>Node.js allows a developer with frontend JavaScript knowledge to leverage their skills on the backend.</p>"},{"location":"framework/nodejs/history/#node-version-manager","title":"Node Version Manager","text":"<p>Node Version Manager (nvm) is a tool that allows multiple editions of Node.js to be installed on the same Linux, macOS, or Windows WSL system. This can be practical if you\u2019re working on two or more projects using different versions of Node.js</p>"},{"location":"framework/nodejs/history/#choosing-a-nodejs-version","title":"Choosing a Node.js Version","text":"<p>Install a recent release of Node.js unless you\u2019re supporting a legacy application with specific requirements.</p> <p>Even-numbered Node.js versions \u2014 such as <code>16</code>, <code>18</code>, and <code>20</code> \u2014 focus on stability and security with long-term support (LTS). Updates are provided for at least two years, so I recommend them for live production servers. You should install an identical version on your development machine.</p> <p>Odd-numbered versions \u2014 such as <code>15</code>, <code>17</code>, <code>19</code> \u2014 are under active development and may have experimental features. They\u2019re fine for development if you\u2019re learning, experimenting, or upgrading frequently.</p>"},{"location":"framework/nodejs/overview/","title":"Overview","text":"<p>Node.js is a JavaScript runtime, which means it runs programs written in JavaScript. (1)</p> <ol> <li> Node.js: Novice to Ninja by SitePoint</li> </ol> <p>Node.js\u2014JavaScript code execution environment outside the browser. This platform allows you to write server-side code for dynamic web pages and web applications, as well as for command-line programs. (1)</p> <ol> <li> <code>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr, pg-11</code>. Using Node.js implements the \u201cJavaScript for everything\u201d paradigm. It involves using a single programming language to develop web applications instead of using different languages to work on the frontend and backend. Node.js is a server platform for working with JavaScript through the V8 engine.</li> </ol> <p>Node.js is very closely related to JavaScript, the syntax and architectural approaches are identical, only the \u201cbindings\u201d (browser and server) differ. (1)</p> <ol> <li> <code>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr, pg-33</code>.</li> </ol>"},{"location":"framework/nodejs/overview/#main-features-of-nodejs","title":"Main Features of Node.js","text":"<ul> <li>Speed</li> <li>Simplicity</li> <li>JavaScript</li> <li>V8 Engine</li> <li>Asynchrony</li> <li>Libraries</li> </ul>"},{"location":"framework/nodejs/overview/#best-use-cases","title":"Best Use Cases","text":"<ol> <li>Real-time applications:</li> <li>Low learning curve:</li> <li>Performance and scalability:</li> <li>NPM support with rich modules:</li> <li>A useful unified code base:</li> <li>Data streaming:</li> <li>Well suited for creating microservices:</li> <li>Strong corporate support:</li> </ol>"},{"location":"framework/nodejs/overview/#books","title":"Books","text":"<ul> <li>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr</li> </ul>"},{"location":"testing/","title":"Overview","text":"<p>api</p>"},{"location":"testing/integration-testing/","title":"Integration testing setup","text":""},{"location":"testing/test-coverage/","title":"Test coverage report","text":""},{"location":"testing/unit-testing/","title":"Unit testing guidelines","text":""},{"location":"tools/overview/","title":"Overview","text":""},{"location":"tools/overview/#backend-tools","title":"Backend Tools","text":""},{"location":"tools/overview/#high-level-roles","title":"\ud83d\udd01 High-Level Roles","text":"<ul> <li>Prometheus: A monitoring and alerting toolkit. It collects, stores, and queries metrics from your applications.</li> <li>Grafana: A visualization and dashboard tool. It connects to Prometheus and displays the metrics.</li> </ul> <p>So the order is:</p> <p>Prometheus first, then Grafana.</p>"},{"location":"tools/overview/#what-to-learn-first","title":"What to Learn First","text":""},{"location":"tools/overview/#1-prometheus-basics","title":"\ud83d\udccc 1. Prometheus Basics","text":"<p>Learn this first, because Grafana depends on Prometheus as a data source.</p> Key Concepts <ul> <li>Metrics format (key-value pairs, usually pulled from <code>/metrics</code>)</li> <li>How Prometheus scrapes targets (your FastAPI app)</li> <li>PromQL: Prometheus Query Language</li> <li>Configuration (<code>prometheus.yml</code>)</li> <li>How to expose metrics from FastAPI (using <code>prometheus_client</code>)</li> </ul> Example metric from FastAPI<pre><code>from prometheus_client import start_http_server, Counter\n\nREQUEST_COUNT = Counter('http_requests_total', 'Total HTTP Requests')\n\n@app.middleware(\"http\")\nasync def count_requests(request: Request, call_next):\n    REQUEST_COUNT.inc()\n    return await call_next(request)\n</code></pre> <p>Then Prometheus scrapes <code>http://&lt;your-app&gt;:8000/metrics</code>.</p>"},{"location":"tools/overview/#2-grafana-basics","title":"\ud83d\udccc 2. Grafana Basics","text":"<p>Once Prometheus is collecting metrics:</p> <ul> <li>Add Prometheus as a data source in Grafana.</li> <li> <p>Create dashboards using:</p> </li> <li> <p>Graphs (time series)</p> </li> <li>Gauges</li> <li>Tables</li> </ul> <p>You can use built-in dashboards or import community ones from Grafana Dashboards.</p>"},{"location":"tools/overview/#local-testing","title":"\ud83d\udd27 Local Testing","text":"<p>You can visit:</p> <ul> <li>Prometheus UI: <code>http://localhost:9090</code></li> </ul> <p>Try simple PromQL queries like:</p> <pre><code>http_requests_total\nrate(http_requests_total[1m])\n</code></pre> <ul> <li>Grafana UI: <code>http://localhost:3000</code></li> </ul> <p>Default login is <code>admin / admin</code>.</p>"},{"location":"tools/overview/#recommended-learning-path","title":"\ud83d\udee0 Recommended Learning Path","text":"<ol> <li> <p>Prometheus:</p> <ul> <li>Learn about scraping targets</li> <li>Learn PromQL basics</li> <li>Understand how metrics are collected</li> </ul> </li> <li> <p>Grafana:</p> <ul> <li>Learn dashboard creation</li> <li>Set up alerts</li> <li>Explore panel types</li> </ul> </li> </ol>"},{"location":"tools/overview/#resources","title":"\ud83d\udcda Resources","text":"<ul> <li>Prometheus Docs</li> <li>Grafana Docs</li> <li>FastAPI Monitoring with Prometheus</li> </ul>"},{"location":"tools/grafana/overview/","title":"Overview","text":""},{"location":"tools/grafana/setup/","title":"Setup","text":""},{"location":"tools/grafana/setup/#setup","title":"Setup","text":""},{"location":"tools/grafana/setup/#set-up-grafana-prometheus-docker","title":"Set Up Grafana + Prometheus (Docker)","text":""},{"location":"tools/grafana/setup/#docker-composeyml","title":"<code>docker-compose.yml</code>","text":"docker-compose.yml<pre><code>version: \"3\"\n\nservices:\n  prometheus:\n    image: prom/prometheus\n    volumes:\n      - ./prometheus.yml:/etc/prometheus/prometheus.yml\n    ports:\n      - \"9090:9090\"\n\n  grafana:\n    image: grafana/grafana\n    ports:\n      - \"3000:3000\"\n\n  fastapi:\n    build: .\n    ports:\n      - \"8000:8000\"\n</code></pre>"},{"location":"tools/grafana/setup/#prometheusyml","title":"prometheus.yml","text":"prometheus.yml<pre><code>global:\n  scrape_interval: 5s\n\nscrape_configs:\n  - job_name: \"fastapi\"\n    static_configs:\n      - targets: [\"host.docker.internal:8000\"]\n</code></pre>"},{"location":"tools/grafana/setup/#dockerfile","title":"Dockerfile","text":"<p>Solution: Create a <code>Dockerfile</code> for FastAPI</p> <p>In your project root (same directory as <code>docker-compose.yml</code>), create a file named exactly <code>Dockerfile</code> (no extension) with the following contents:</p> <pre><code># Dockerfile for FastAPI app\n\nFROM python:3.12-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1\nENV PYTHONUNBUFFERED=1\n\n# Set working directory\nWORKDIR /app\n\n# Install pipenv\nRUN pip install pipenv\n\n# Copy Pipfile and install dependencies\nCOPY Pipfile Pipfile.lock ./\nRUN pipenv install --system --deploy --ignore-pipfile\n\n# Copy the application code\nCOPY . .\n\n# Expose FastAPI port\nEXPOSE 8000\n\n# Start the FastAPI app\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre> <p>\u2705 Then Try Again</p> <p>Once the <code>Dockerfile</code> is in place, run:</p> <pre><code>sudo docker-compose up --build\n</code></pre> <p>Optional: <code>.dockerignore</code></p> <p>Create a <code>.dockerignore</code> file to avoid copying unnecessary files into the contain</p> <pre><code>__pycache__/\n*.pyc\n*.pyo\n*.pyd\n.env\n.git\n</code></pre>"},{"location":"tools/grafana/setup/#build-and-run-all-services","title":"Build and Run All Services","text":"<pre><code>docker-compose up\n\n# or\n\nsudo docker-compose up\n</code></pre>"},{"location":"tools/grafana/setup/#access-grafana","title":"Access Grafana","text":"<ul> <li> <p>Grafana UI: http://localhost:3000</p> </li> <li> <p>Default login: <code>admin / admin</code></p> </li> </ul> <p>Add Prometheus as a data source:</p> <ul> <li>URL: <code>http://prometheus:9090</code></li> </ul> <p>Then create a dashboard using the metric <code>request_count</code>.</p> Check Docker Socket <p>See if the Docker socket exists:</p> <pre><code>ls -l /var/run/docker.sock\n</code></pre> <p>You should see something like:</p> <pre><code>srw-rw---- 1 root docker 0 Aug 2 12:34 /var/run/docker.sock\n</code></pre> <p>If you\u2019re not in the <code>docker</code> group, add yourself:</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>Then log out and back in, or run:</p> <pre><code>newgrp docker\n</code></pre> Try Using Docker with <code>sudo</code> <p>If nothing else works:</p> <pre><code>sudo docker-compose up\n</code></pre> <p>If this works, it's definitely a permissions issue.</p>"},{"location":"tools/observability-stack/overview/","title":"Overview","text":""},{"location":"tools/observability-stack/overview/#overview","title":"Overview","text":""},{"location":"tools/observability-stack/overview/#overview_1","title":"Overview","text":"<p>observability is a foundational concept in modern software development and DevOps.</p>"},{"location":"tools/observability-stack/overview/#what-is-an-observability-stack","title":"What Is an Observability Stack?","text":"<p>An observability stack is a set of tools and practices that allow you to understand what's happening inside your application or system, especially when things go wrong.</p> <p>It helps you answer:</p> <ul> <li>\u201cWhy is my app slow?\u201d</li> <li>\u201cWhy did this service fail?\u201d</li> <li>\u201cWhat caused this spike in traffic?\u201d</li> </ul>"},{"location":"tools/observability-stack/overview/#core-pillars-of-observability","title":"\ud83d\udcca Core Pillars of Observability","text":"<p>There are three key types of data in an observability stack, often called the 3 Pillars:</p> Pillar Description Example Tools Metrics Numeric time-series data about your system (e.g., CPU usage, requests/sec) Prometheus, InfluxDB Logs Textual records of events (e.g., error messages, request logs) Loki, ELK (Elasticsearch, Logstash, Kibana), Fluentd Traces End-to-end request flows through a system (e.g., what microservices were called and how long they took) Jaeger, Zipkin, OpenTelemetry"},{"location":"tools/observability-stack/overview/#typical-observability-stack","title":"\ud83e\uddf1 Typical Observability Stack","text":"<p>Here\u2019s a commonly used open-source observability stack:</p> Layer Tool Role Metrics Prometheus Collects &amp; stores metrics Visualization Grafana Dashboards &amp; alerts using Prometheus Logs Loki Stores and queries logs Tracing Jaeger or Tempo Tracks request paths across services Instrumentation OpenTelemetry Common API for collecting data"},{"location":"tools/observability-stack/overview/#why-is-it-useful","title":"\ud83e\udde0 Why Is It Useful?","text":"<ul> <li>Detect outages or slowdowns early</li> <li>Pinpoint bottlenecks and errors</li> <li>Provide alerts to engineers</li> <li>Improve incident response time</li> <li>Help with root cause analysis</li> </ul>"},{"location":"tools/observability-stack/overview/#fastapi-observability-stack-example","title":"\ud83d\ude80 FastAPI + Observability Stack (Example)","text":"<p>For your case with FastAPI:</p> <ul> <li>Metrics: Use <code>prometheus_client</code> to expose <code>/metrics</code></li> <li>Prometheus: Scrapes that endpoint</li> <li>Grafana: Visualizes metrics</li> <li>(Optional) Add logs (with Loki) and tracing (with OpenTelemetry)</li> </ul>"},{"location":"tools/observability-stack/overview/#setting-up-observability-stack-for-fastapi","title":"Setting up Observability Stack for FastAPI","text":"<p>Here's a basic Observability Stack for a FastAPI app using:</p> <ul> <li>\ud83d\udfe1 FastAPI</li> <li>\ud83d\udd35 Prometheus (metrics collector)</li> <li>\ud83d\udfe2 Grafana (dashboard/visualizer)</li> </ul> <p>Later, you can extend it with logging (e.g. <code>Loki</code>) and tracing (e.g. <code>Jaeger</code>).</p>"},{"location":"tools/observability-stack/overview/#docker-compose-setup","title":"\ud83d\udc33 Docker Compose Setup","text":"<p>Here's a minimal <code>docker-compose.yml</code> for:</p> <ol> <li>Your FastAPI app</li> <li>Prometheus</li> <li>Grafana</li> </ol>"},{"location":"tools/observability-stack/overview/#folder-structure","title":"\ud83d\udcc1 Folder Structure","text":"<pre><code>my-observability-stack/\n\u2502\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 prometheus/\n\u2502   \u2514\u2500\u2500 prometheus.yml\n</code></pre>"},{"location":"tools/observability-stack/overview/#docker-composeyml","title":"\ud83d\udce6 <code>docker-compose.yml</code>","text":"<pre><code>version: \"3.8\"\n\nservices:\n  fastapi:\n    build: ./app\n    ports:\n      - \"8000:8000\"\n    networks:\n      - monitor-net\n\n  prometheus:\n    image: prom/prometheus\n    volumes:\n      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml\n    ports:\n      - \"9090:9090\"\n    networks:\n      - monitor-net\n\n  grafana:\n    image: grafana/grafana\n    ports:\n      - \"3000:3000\"\n    networks:\n      - monitor-net\n\nnetworks:\n  monitor-net:\n</code></pre>"},{"location":"tools/observability-stack/overview/#prometheusprometheusyml","title":"\ud83d\udd27 <code>prometheus/prometheus.yml</code>","text":"<pre><code>global:\n  scrape_interval: 5s\n\nscrape_configs:\n  - job_name: \"fastapi\"\n    static_configs:\n      - targets: [\"fastapi:8000\"]\n</code></pre>"},{"location":"tools/observability-stack/overview/#appmainpy","title":"\ud83d\udc0d <code>app/main.py</code>","text":"<pre><code>from fastapi import FastAPI, Request\nfrom prometheus_client import start_http_server, Counter, generate_latest\nfrom prometheus_client import CONTENT_TYPE_LATEST\nfrom starlette.responses import Response\nimport uvicorn\n\nREQUEST_COUNTER = Counter(\"http_requests_total\", \"Total HTTP Requests\")\n\napp = FastAPI()\n\n@app.middleware(\"http\")\nasync def add_metrics_middleware(request: Request, call_next):\n    REQUEST_COUNTER.inc()\n    response = await call_next(request)\n    return response\n\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Hello from FastAPI!\"}\n\n@app.get(\"/metrics\")\ndef metrics():\n    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)\n</code></pre>"},{"location":"tools/observability-stack/overview/#apprequirementstxt","title":"\ud83d\udce6 <code>app/requirements.txt</code>","text":"<pre><code>fastapi\nuvicorn\nprometheus_client\n</code></pre>"},{"location":"tools/observability-stack/overview/#build-and-run","title":"\ud83c\udfc3\u200d\u2642\ufe0f Build and Run","text":"<p>From the project root:</p> <pre><code>docker-compose up --build\n\n#or\n\nsudo docker-compose up --build\n</code></pre>"},{"location":"tools/observability-stack/overview/#access-urls","title":"\ud83d\udd17 Access URLs","text":"Tool URL FastAPI http://localhost:8000 Metrics http://localhost:8000/metrics Prometheus http://localhost:9090 Grafana http://localhost:3000 <p>Grafana login: <code>admin / admin</code> (change after login)</p>"},{"location":"tools/observability-stack/overview/#in-grafana","title":"\ud83d\udcc8 In Grafana","text":"<ol> <li> <p>Go to <code>http://localhost:3000</code></p> </li> <li> <p>Add data source:</p> <ul> <li>Type: Prometheus</li> <li>URL: <code>http://prometheus:9090</code></li> </ul> </li> <li> <p>Create a dashboard with a panel.</p> <ul> <li>Use query: <code>http_requests_total</code></li> </ul> </li> </ol>"},{"location":"tools/observability-stack/overview/#next-steps","title":"\u2705 Next Steps","text":"<p>Once you get this working:</p> <ul> <li>Add Loki for logging</li> <li>Add Tempo or Jaeger for tracing</li> <li>Use OpenTelemetry for standardized instrumentation</li> </ul> <p>Would you like me to add logging (Loki) or tracing (Jaeger) next?</p>"},{"location":"tools/observability-stack/overview/#text-based-flowchart-style-diagram-visulization","title":"text-based, flowchart-style diagram VISULIZATION","text":"<p>Docker Compose Observability Stack with:</p> <ul> <li>FastAPI App</li> <li>Prometheus</li> <li>Grafana</li> </ul> <pre><code>+----------------------------+\n|     FastAPI Application    |\n|  - Runs on port 8000       |\n|  - Exposes /metrics        |\n+----------------------------+\n              |\n              V\n+----------------------------+\n|        Prometheus          |\n|  - Scrapes /metrics        |\n|  - Stores time-series data |\n|  - Uses prometheus.yml     |\n+----------------------------+\n              |\n              V\n+----------------------------+\n|          Grafana           |\n|  - Connects to Prometheus  |\n|  - Visualizes metrics      |\n|  - Dashboards &amp; Alerts     |\n+----------------------------+\n              |\n              V\n+----------------------------+\n|          You (User)        |\n|  - View metrics in browser |\n|  - Analyze, debug, monitor |\n+----------------------------+\n</code></pre> <p>\ud83d\udd04 Docker Compose Networking</p> <p>All services are on the same Docker network, so they can reach each other by container name:</p> <ul> <li>Prometheus can scrape FastAPI via <code>http://fastapi:8000/metrics</code></li> <li>Grafana connects to Prometheus via <code>http://prometheus:9090</code></li> </ul> <p>\ud83d\udce6 Updated Docker Compose Diagram (Text-Based)</p> <pre><code>+----------------------------+\n|     FastAPI Application    |\n|  - Exposes:                |\n|     \u2022 /metrics (Prometheus)|\n|     \u2022 Logs (Loki)          |\n|     \u2022 Traces (Jaeger)      |\n+----------------------------+\n       |       |       |\n       |       |       |\n       V       V       V\n+-----------+ +----------+ +----------+\n| Prometheus| |   Loki   | |  Jaeger  |\n|  Metrics  | |   Logs   | | Traces   |\n+-----------+ +----------+ +----------+\n       \\        |        /\n        \\       |       /\n         V      V      V\n         +------------------------+\n         |        Grafana         |\n         | - Dashboards (All Data)|\n         +------------------------+\n                     |\n                     V\n            +------------------+\n            |   You (Developer)|\n            +------------------+\n</code></pre> <p>\ud83d\udc33 Next Step: Add Loki and Jaeger to <code>docker-compose.yml</code></p> <p>Would you like me to:</p> <ol> <li>\ud83d\udd27 Give you the full updated <code>docker-compose.yml</code> with Loki &amp; Jaeger?</li> <li>\ud83d\udcc2 Provide file structure + config files (e.g. for Loki and Promtail)?</li> <li>\u2705 Or just a minimal Loki &amp; Jaeger config added to your existing stack?</li> </ol> <p>Let me know your preference, and I\u2019ll tailor it for you.</p>"},{"location":"tools/observability-stack/stack-architecture/","title":"Stack Architecture","text":""},{"location":"tools/observability-stack/stack-architecture/#observability-stack-architecture","title":"\ud83e\uddf1 Observability Stack Architecture","text":"<p>This document outlines the architecture of a modern observability stack using:</p> <ul> <li>Prometheus for metrics</li> <li>Loki for logs</li> <li>Tempo for traces</li> <li>Grafana as the unified dashboard</li> </ul> <p>This stack provides full visibility into your application's health, behavior, and performance.</p>"},{"location":"tools/observability-stack/stack-architecture/#overview","title":"\ud83e\udded Overview","text":"<p>\ud83d\udd0d Observability answers:</p> <ul> <li>What is happening? (Metrics)</li> <li>Why is it happening? (Logs)</li> <li>Where did it happen? (Traces)</li> </ul>"},{"location":"tools/observability-stack/stack-architecture/#core-components","title":"\ud83e\uddca Core Components","text":"Component Purpose Visualization Prometheus Scrapes metrics from applications Grafana Loki Collects and indexes logs Grafana Tempo Collects distributed traces Grafana Grafana Visualizes all of the above Web UI"},{"location":"tools/observability-stack/stack-architecture/#architecture-diagram","title":"\ud83e\uddec Architecture Diagram","text":"<pre><code>                        +--------------------------+\n                        |      Grafana Dashboards  |\n                        |   (Metrics / Logs / Traces) |\n                        +-----------+--------------+\n                                    |\n      +-----------------------------+-----------------------------+\n      |                             |                             |\n+-------------+           +------------------+         +------------------+\n| Prometheus  | &lt;---scrapes--- |   FastAPI App   | --traces--&gt; |     Tempo         |\n| (metrics)   |               | (via /metrics)  |             | (tracing backend) |\n+-------------+               +------------------+             +------------------+\n                                    |\n                             logs via stdout\n                                    |\n                             +--------------+\n                             |     Promtail |\n                             | (or Grafana Agent) |\n                             +--------------+\n                                    |\n                               +--------+\n                               |  Loki  |\n                               +--------+\n</code></pre>"},{"location":"tools/observability-stack/stack-architecture/#data-flow-summary","title":"\u2699\ufe0f Data Flow Summary","text":"<ol> <li> <p>Metrics (Prometheus):</p> <ul> <li>Your FastAPI app exposes metrics via <code>/metrics</code> (e.g., with <code>prometheus_client</code>)</li> <li>Prometheus scrapes them periodically</li> <li>Grafana queries and visualizes them</li> </ul> </li> <li> <p>Logs (Loki):</p> <ul> <li>Application logs (e.g., <code>loguru</code>, <code>structlog</code>, <code>uvicorn</code>) go to <code>stdout</code></li> <li>Promtail or Grafana Agent tails logs and sends them to Loki</li> <li>Logs are labeled (e.g., by service, pod, env) and searchable in Grafana</li> </ul> </li> <li> <p>Traces (Tempo):</p> <ul> <li>FastAPI app is instrumented using OpenTelemetry</li> <li>Requests generate traces (including spans for DB, HTTP, etc.)</li> <li>Traces are exported via OTLP to Tempo</li> <li>Tempo stores and indexes traces for viewing in Grafana</li> </ul> </li> </ol>"},{"location":"tools/observability-stack/stack-architecture/#component-integration","title":"\ud83e\udde9 Component Integration","text":"Tool Input Source Output / Integration Prometheus <code>/metrics</code> endpoint Grafana dashboards, Alerts Loki Logs from stdout/stderr Grafana Explore Tempo OpenTelemetry SDK Grafana trace viewer Grafana Prometheus, Loki, Tempo Unified view"},{"location":"tools/observability-stack/stack-architecture/#benefits-of-this-stack","title":"\u2705 Benefits of This Stack","text":"<ul> <li>Single pane of glass: All telemetry in one UI</li> <li>Correlated insights: Link logs \u2194 traces \u2194 metrics</li> <li>Open source and cloud-native</li> <li>Minimal vendor lock-in (fully OSS or self-hostable)</li> </ul>"},{"location":"tools/observability-stack/stack-architecture/#example-use-case","title":"\ud83d\udee0\ufe0f Example Use Case","text":"<p>Issue: Latency spike on <code>/api/orders</code></p> <p>With this stack you can:</p> <ol> <li>Use Prometheus to see when latency increased</li> <li>Click a spike in Grafana \u2192 view Tempo trace</li> <li>Trace shows DB query took 1.2s</li> <li>Jump to Loki logs for same <code>trace_id</code></li> <li>See error log: <code>\u201cIndex on orders.created_at missing\u201d</code></li> </ol> <p>\u2705 You identified what, where, and why \u2014 across tools in seconds.</p>"},{"location":"tools/observability-stack/stack-architecture/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Metrics with Prometheus</li> <li>Logging with Loki</li> <li>Tracing with Tempo and FastAPI</li> </ul>"},{"location":"tools/observability-stack/topics/","title":"Topic","text":""},{"location":"tools/observability-stack/topics/#topic","title":"Topic","text":"<p>That's great\u2014you\u2019ve already touched on some important observability tools like Prometheus and Grafana, and you're using FastAPI, a modern and high-performance Python web framework. That\u2019s a solid start!</p>"},{"location":"tools/observability-stack/topics/#overview","title":"Overview","text":"<p>To master advanced backend programming, here\u2019s a structured list of advanced backend topics, categorized for clarity:</p>"},{"location":"tools/observability-stack/topics/#1-system-design-architecture","title":"\ud83d\udd27 1. System Design &amp; Architecture","text":"<p>Understanding how to architect systems is crucial.</p> <ul> <li>Microservices Architecture</li> <li>Monolith vs Microservices vs Serverless</li> <li>API Gateway (e.g., Kong, NGINX, Envoy)</li> <li>Service Mesh (e.g., Istio, Linkerd)</li> <li>Domain-Driven Design (DDD)</li> <li>Event-Driven Architecture (with Kafka or RabbitMQ)</li> <li>Clean Architecture &amp; Hexagonal Architecture</li> <li>Load balancing, failover strategies</li> </ul>"},{"location":"tools/observability-stack/topics/#2-performance-scalability","title":"\u2699\ufe0f 2. Performance &amp; Scalability","text":"<ul> <li>Horizontal vs Vertical Scaling</li> <li>Caching: Redis, Memcached, CDN usage</li> <li>Asynchronous Programming: <code>asyncio</code>, <code>celery</code>, <code>kombu</code></li> <li>Rate Limiting / Throttling</li> <li>Backpressure handling</li> </ul>"},{"location":"tools/observability-stack/topics/#3-security","title":"\ud83d\udd10 3. Security","text":"<ul> <li>OAuth2, JWT, OpenID Connect</li> <li>TLS/SSL, HTTPS, CSRF, XSS, CORS</li> <li>API Security Best Practices</li> <li>Authentication &amp; Authorization Layers</li> <li>Secrets Management (Vault, AWS Secrets Manager)</li> </ul>"},{"location":"tools/observability-stack/topics/#4-devops-observability","title":"\ud83d\udce6 4. DevOps &amp; Observability","text":"<p>You\u2019ve started with Prometheus + Grafana, which is great.</p> <p>Add:</p> <ul> <li>Logging: ELK Stack (Elasticsearch, Logstash, Kibana), Loki</li> <li>Tracing: OpenTelemetry, Jaeger</li> <li>Metrics: Custom metrics with Prometheus</li> <li>Alerting: Prometheus Alertmanager</li> <li>Docker &amp; Containerization</li> <li>CI/CD Pipelines: GitHub Actions, GitLab CI, Jenkins</li> </ul>"},{"location":"tools/observability-stack/topics/#5-databases-sql-nosql","title":"\ud83d\uddc3\ufe0f 5. Databases (SQL + NoSQL)","text":"<ul> <li>Advanced SQL Queries, Indexing, Query Planning</li> <li>PostgreSQL or MySQL Internals</li> <li>NoSQL (MongoDB, Cassandra, DynamoDB)</li> <li>Database Scaling: Sharding, Replication</li> <li>ORM Performance Optimization</li> <li>Migrations &amp; Schema Management</li> </ul>"},{"location":"tools/observability-stack/topics/#6-messaging-queue-systems","title":"\ud83d\udef0\ufe0f 6. Messaging &amp; Queue Systems","text":"<ul> <li>Kafka, RabbitMQ, Redis Streams</li> <li>Message patterns: Pub/Sub, Fanout, Dead Letter Queues</li> <li>Idempotency and retry handling</li> </ul>"},{"location":"tools/observability-stack/topics/#7-testing-quality-assurance","title":"\ud83e\uddea 7. Testing &amp; Quality Assurance","text":"<ul> <li>Unit, Integration, End-to-End Testing</li> <li>Load Testing (Locust, k6)</li> <li>Contract Testing (e.g., Pact)</li> <li>Test-Driven Development (TDD)</li> </ul>"},{"location":"tools/observability-stack/topics/#8-cloud-infrastructure","title":"\u2601\ufe0f 8. Cloud &amp; Infrastructure","text":"<ul> <li>AWS / GCP / Azure Core Services</li> <li>IaC (Infrastructure as Code): Terraform, Pulumi</li> <li>Kubernetes Basics + Advanced Concepts</li> <li>Networking (VPC, subnets, NAT, firewall rules)</li> </ul>"},{"location":"tools/observability-stack/topics/#9-advanced-api-design","title":"\ud83d\udcf1 9. Advanced API Design","text":"<ul> <li>Versioning</li> <li>Pagination, Filtering, Sorting</li> <li>GraphQL APIs</li> <li>gRPC / Protobuf</li> <li>HATEOAS / REST maturity levels</li> </ul>"},{"location":"tools/observability-stack/topics/#10-real-world-scalability-practices","title":"\ud83d\udcc8 10. Real-World Scalability Practices","text":"<ul> <li>Circuit Breakers / Bulkheads (e.g., Resilience4j)</li> <li>Distributed Tracing</li> <li>Handling Failures Gracefully</li> <li>Chaos Engineering Basics (e.g., Gremlin)</li> </ul>"},{"location":"tools/observability-stack/topics/#suggestions-to-deepen-knowledge","title":"\ud83d\udcda Suggestions to Deepen Knowledge","text":"<ul> <li>Read \"Designing Data-Intensive Applications\" by Martin Kleppmann</li> <li>Explore \u201cThe Pragmatic Programmer\u201d</li> <li>Study case studies of companies like Netflix, Uber, etc.</li> </ul>"},{"location":"tools/observability-stack/topics/#roadmap","title":"Roadmap","text":"<p>Would you like me to organize a learning roadmap with these topics prioritized for you based on your current knowledge (e.g., with FastAPI and Prometheus)?</p> <p>Great! Since you're already using FastAPI and have worked with Prometheus + Grafana, I'll assume:</p> <ul> <li>You\u2019re comfortable with Python and basic web APIs.</li> <li>You understand HTTP, routing, and REST basics.</li> <li>You\u2019ve deployed or monitored a service at least in development/staging.</li> </ul> <p>Here\u2019s a personalized roadmap to mastering advanced backend development, broken into 4 levels:</p>"},{"location":"tools/observability-stack/topics/#phase-1-strengthen-the-core","title":"\ud83e\udde9 Phase 1: Strengthen the Core","text":"<p>Goal: Deepen your understanding of backend fundamentals and build robust, clean APIs.</p> <p>Topics:</p> <ul> <li> <p>\u2705 Advanced FastAPI</p> </li> <li> <p>Dependency injection</p> </li> <li>Background tasks</li> <li>WebSockets</li> <li>Middleware</li> <li> <p>FastAPI + Pydantic V2 performance tuning</p> </li> <li> <p>\u2705 SQL Mastery (PostgreSQL/MySQL)</p> </li> <li> <p>Joins, indexes, query planning</p> </li> <li>Transactions &amp; isolation levels</li> <li> <p>ORMs (SQLAlchemy Core vs ORM)</p> </li> <li> <p>\u2705 Caching</p> </li> <li> <p>Redis for in-memory caching</p> </li> <li> <p>Cache invalidation strategies</p> </li> <li> <p>\u2705 Authentication &amp; Authorization</p> </li> <li> <p>JWT, OAuth2 with FastAPI</p> </li> <li>Role-based access control (RBAC)</li> </ul>"},{"location":"tools/observability-stack/topics/#phase-2-build-production-grade-systems","title":"\ud83e\uddf1 Phase 2: Build Production-Grade Systems","text":"<p>Goal: Learn how to scale, monitor, and secure services in real-world environments.</p> <p>Topics:</p> <ul> <li> <p>\u2705 Observability</p> </li> <li> <p>Prometheus: custom metrics</p> </li> <li>Grafana dashboards</li> <li>Logging (Structlog, Loguru, or ELK)</li> <li> <p>Tracing with OpenTelemetry or Jaeger</p> </li> <li> <p>\u2705 Asynchronous Programming</p> </li> <li> <p>Python <code>asyncio</code>, FastAPI async routes</p> </li> <li> <p>Task queues: Celery, Redis Queue</p> </li> <li> <p>\u2705 Docker &amp; Docker Compose</p> </li> <li> <p>Build, run, network multiple services</p> </li> <li> <p>\u2705 Testing</p> </li> <li> <p>Pytest: unit, integration, and E2E</p> </li> <li>Test coverage, mocking, fixtures</li> </ul>"},{"location":"tools/observability-stack/topics/#phase-3-advanced-architecture-devops","title":"\ud83c\udf10 Phase 3: Advanced Architecture &amp; DevOps","text":"<p>Goal: Design scalable, resilient systems and manage deployments like a pro.</p> <p>Topics:</p> <ul> <li> <p>\u2705 System Design Basics</p> </li> <li> <p>Load balancers, reverse proxies</p> </li> <li> <p>Horizontal scaling, stateless services</p> </li> <li> <p>\u2705 API Gateway Concepts</p> </li> <li> <p>Kong, NGINX, or Traefik usage</p> </li> <li> <p>\u2705 CI/CD Pipelines</p> </li> <li> <p>GitHub Actions or GitLab CI</p> </li> <li> <p>Auto-deploy on push or merge</p> </li> <li> <p>\u2705 Infrastructure as Code</p> </li> <li> <p>Terraform (AWS/GCP basics)</p> </li> <li> <p>\u2705 Cloud</p> </li> <li> <p>AWS core services: EC2, RDS, S3, IAM</p> </li> <li>Deploying FastAPI with Gunicorn + NGINX</li> </ul>"},{"location":"tools/observability-stack/topics/#phase-4-high-level-architecture-real-world-practices","title":"\u26a1 Phase 4: High-Level Architecture &amp; Real-World Practices","text":"<p>Goal: Learn how large-scale systems work and how to design fault-tolerant, scalable APIs.</p> <p>Topics:</p> <ul> <li> <p>\u2705 Message Brokers</p> </li> <li> <p>Kafka or RabbitMQ</p> </li> <li> <p>Event-driven design (Pub/Sub)</p> </li> <li> <p>\u2705 Microservices Architecture</p> </li> <li> <p>Service discovery</p> </li> <li>Inter-service communication (REST, gRPC)</li> <li> <p>Database per service pattern</p> </li> <li> <p>\u2705 Advanced API Design</p> </li> <li> <p>Pagination, filtering, versioning</p> </li> <li>GraphQL vs REST trade-offs</li> <li> <p>gRPC with Python</p> </li> <li> <p>\u2705 Distributed Systems Concepts</p> </li> <li> <p>CAP theorem, consistency models</p> </li> <li>Circuit breakers, retries, timeouts</li> <li>Idempotency in distributed APIs</li> </ul>"},{"location":"tools/observability-stack/topics/#bonus-reading-projects","title":"\ud83e\udde0 Bonus Reading &amp; Projects","text":"<p>Books:</p> <ul> <li>Designing Data-Intensive Applications \u2013 Martin Kleppmann</li> <li>The Phoenix Project (DevOps focus)</li> <li>Clean Architecture \u2013 Uncle Bob</li> </ul> <p>Projects to Try:</p> <ul> <li>\ud83d\uded2 E-commerce microservice (cart, auth, orders)</li> <li>\ud83d\ude80 Real-time chat app (WebSocket + Redis)</li> <li>\ud83d\udcca Monitoring dashboard (Prometheus + custom metrics)</li> <li>\ud83c\udf0d API gateway proxy in front of multiple microservices</li> </ul>"},{"location":"tools/prometheus/overview/","title":"Overview","text":""},{"location":"tools/prometheus/setup/","title":"Setup","text":""},{"location":"tools/prometheus/setup/#setup","title":"Setup","text":"<p>To set up a FastAPI app with Prometheus for metrics and Grafana for visualization</p> <pre><code>pipenv install fastapi uvicorn prometheus-fastapi-instrumentator\n\n# or\n\npipenv install fastapi uvicorn prometheus_client\n</code></pre> <p>For development (auto-reload, etc.):</p> <pre><code>pipenv install --dev python-dotenv\n</code></pre> <p>The difference between prometheus_client and prometheus-fastapi-instrumentator lies in abstraction level, ease of use, and target use-case:</p>"},{"location":"tools/prometheus/setup/#prometheus_client","title":"\ud83d\udd27 <code>prometheus_client</code>","text":"<p>What it is:</p> <ul> <li>The official low-level Python client for Prometheus.</li> <li>Lets you define and manage metrics manually (counters, histograms, gauges, etc.).</li> <li>Framework-agnostic (can be used with FastAPI, Flask, Django, etc.).</li> </ul> <p>Use it when:</p> <ul> <li>You want fine-grained control over metrics.</li> <li>You're building custom instrumentation.</li> <li>You're not using FastAPI or need something portable.</li> <li>You are okay with writing more boilerplate (e.g., creating endpoints, tracking latencies manually).</li> </ul> <p>Pros:</p> <ul> <li>Full control.</li> <li>Official and well-maintained.</li> <li>No external abstraction.</li> </ul> <p>Cons:</p> <ul> <li>More boilerplate.</li> <li>Not plug-and-play with FastAPI.</li> </ul>"},{"location":"tools/prometheus/setup/#prometheus-fastapi-instrumentator","title":"\ud83d\ude80 <code>prometheus-fastapi-instrumentator</code>","text":"<p>What it is:</p> <ul> <li>A high-level wrapper around <code>prometheus_client</code> for FastAPI applications.</li> <li>Automatically instruments common metrics like HTTP request durations, status codes, path info, etc.</li> <li>Adds a ready-made <code>/metrics</code> endpoint.</li> <li>Allows customization, but handles most Prometheus boilerplate for you.</li> </ul> <p>Use it when:</p> <ul> <li>You're using FastAPI.</li> <li>You want easy and fast instrumentation.</li> <li>You're okay with some abstraction.</li> <li>You want to avoid manual metric wiring for HTTP metrics.</li> </ul> <p>Pros:</p> <ul> <li>Plug-and-play.</li> <li>Auto-instruments your app.</li> <li>Saves time for typical web metrics.</li> </ul> <p>Cons:</p> <ul> <li>Slightly less control than <code>prometheus_client</code>.</li> <li>Adds an extra dependency.</li> <li>Not suited for non-FastAPI apps.</li> </ul>"},{"location":"tools/prometheus/setup/#which-one-should-you-use","title":"\u2705 Which One Should You Use?","text":"Use Case Recommendation You're using FastAPI and want easy metrics (request count, latency, etc.) \u2705 Use <code>prometheus-fastapi-instrumentator</code> You're building a custom metrics system or working outside FastAPI \u2705 Use <code>prometheus_client</code> You need both: automatic HTTP metrics and some custom metrics Use both together (the instrumentator internally uses <code>prometheus_client</code>)"},{"location":"tools/prometheus/setup/#example","title":"Example:","text":"<p><code>prometheus-fastapi-instrumentator</code>:</p> <pre><code>from fastapi import FastAPI\nfrom prometheus_fastapi_instrumentator import Instrumentator\n\napp = FastAPI()\nInstrumentator().instrument(app).expose(app)\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n</code></pre> <p><code>prometheus_client</code> (manual):</p> <pre><code>from fastapi import FastAPI, Request\nfrom prometheus_client import Counter, generate_latest\nfrom starlette.responses import Response\n\napp = FastAPI()\nREQUEST_COUNT = Counter(\"request_count\", \"Total number of requests\")\n\n@app.middleware(\"http\")\nasync def count_requests(request: Request, call_next):\n    REQUEST_COUNT.inc()\n    return await call_next(request)\n\n@app.get(\"/metrics\")\ndef metrics():\n    return Response(generate_latest(), media_type=\"text/plain\")\n</code></pre> <p>If you're prototyping, building APIs quickly, or don\u2019t need full control: start with <code>prometheus-fastapi-instrumentator</code>. You can always drop down to <code>prometheus_client</code> if needed.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""}]}