{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Back of my mind","text":""},{"location":"#back-of-my-mind","title":"Back of my mind","text":"<p>Icons8: Free Icon</p> <pre><code>my-backend-docs/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md                # Home page\n\u2502   \u251c\u2500\u2500 installation.md         # Installation guide\n\u2502   \u251c\u2500\u2500 setup.md                # Setup instructions\n\u2502   \u251c\u2500\u2500 architecture.md         # System architecture overview\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # API overview\n\u2502   \u2502   \u251c\u2500\u2500 authentication.md   # Authentication &amp; Authorization\n\u2502   \u2502   \u251c\u2500\u2500 endpoints.md        # List of API endpoints\n\u2502   \u2502   \u251c\u2500\u2500 rate-limiting.md    # Rate limiting and throttling\n\u2502   \u2502   \u251c\u2500\u2500 error-handling.md   # Error handling and response codes\n\u2502   \u251c\u2500\u2500 database/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Database overview\n\u2502   \u2502   \u251c\u2500\u2500 schema.md           # Database schema\n\u2502   \u2502   \u251c\u2500\u2500 migrations.md       # Migration guide\n\u2502   \u2502   \u251c\u2500\u2500 relationships.md    # Entity relationships (ERD)\n\u2502   \u251c\u2500\u2500 testing/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Testing overview\n\u2502   \u2502   \u251c\u2500\u2500 unit-testing.md     # Unit testing guidelines\n\u2502   \u2502   \u251c\u2500\u2500 integration-testing.md  # Integration testing setup\n\u2502   \u2502   \u251c\u2500\u2500 test-coverage.md    # Test coverage report\n\u2502   \u251c\u2500\u2500 deployment/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Deployment guide\n\u2502   \u2502   \u251c\u2500\u2500 ci-cd.md            # CI/CD setup\n\u2502   \u2502   \u251c\u2500\u2500 docker.md           # Docker setup\n\u2502   \u251c\u2500\u2500 troubleshooting.md      # Common issues and solutions\n\u2502   \u251c\u2500\u2500 best-practices.md       # Backend best practices (security, scalability, etc.)\n\u2502   \u251c\u2500\u2500 glossary.md             # Glossary of terms\n\u251c\u2500\u2500 mkdocs.yml                  # MkDocs configuration file\n</code></pre>"},{"location":"#should-you-learn-nodejs-before-express","title":"Should You Learn Node.js Before Express?","text":"<p>Yes, it's recommended to learn <code>Node.js</code> first before diving into <code>Express.js</code>. Here\u2019s why:</p> <ol> <li> <p>Node.js is the foundation:</p> <ul> <li> <p>Express is a web framework built on top of Node.js, so understanding how Node works will make it much easier to understand how Express fits into the picture.</p> </li> <li> <p>Node.js provides the JavaScript runtime on the server, handling things like file I/O, HTTP requests, and event-driven programming. Express abstracts much of this functionality and makes it easier to work with, but if you don\u2019t understand the basics of Node, you might feel lost when things go wrong.</p> </li> </ul> </li> <li> <p>Understanding Node Basics: Before you jump into Express, make sure you understand:</p> <ul> <li>How to use Node.js modules (like <code>fs</code>, <code>http</code>, <code>path</code>).</li> <li>The event-driven architecture and how Node uses a single-threaded model for non-blocking I/O.</li> <li>How to create HTTP servers and handle requests and responses in pure Node.js (without Express).</li> <li>How npm (Node Package Manager) works for managing dependencies.</li> </ul> </li> <li> <p>Express Simplifies Node:</p> <ul> <li>Express is built on top of Node and provides a simplified API for handling HTTP requests, routing, middleware, and so on. It does a lot of the heavy lifting for you, making Node development easier and faster. However, if you don\u2019t know the underlying concepts of Node.js, you might not fully appreciate how Express is working under the hood.</li> </ul> </li> </ol> Suggested Learning Order <ol> <li> <p>Learn Node.js basics first:</p> <ul> <li>Understand Event Loop, callbacks, promises, and async/await.</li> <li>Learn how to create simple web servers using the built-in <code>http</code> module.</li> <li>Explore how to handle file operations, work with the file system (<code>fs</code>), and make network requests (using <code>http</code>, <code>https</code> modules).</li> </ul> </li> <li> <p>Learn Express.js:</p> <ul> <li>Once you're comfortable with Node.js, you can jump into Express. You\u2019ll see how Express simplifies the HTTP server creation process, helps with routing, middleware handling, and provides utilities for common backend tasks.</li> </ul> </li> </ol> <p>Example: Node.js vs Express</p> <p>Let\u2019s compare writing a basic web server in Node.js versus Express:</p> <p>Node.js (Barebones HTTP Server):</p> <pre><code>const http = require(\"http\");\n\nconst server = http.createServer((req, res) =&gt; {\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"text/plain\");\n  res.end(\"Hello, world!\");\n});\n\nserver.listen(3000, \"127.0.0.1\", () =&gt; {\n  console.log(\"Server running at http://127.0.0.1:3000/\");\n});\n</code></pre> <p>Express (Same Server):</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.get(\"/\", (req, res) =&gt; {\n  res.send(\"Hello, world!\");\n});\n\napp.listen(3000, () =&gt; {\n  console.log(\"Server running at http://localhost:3000\");\n});\n</code></pre> <p>With Express, you don\u2019t need to manually set up headers, status codes, or handle the routing manually. Express makes it much simpler to write server code, especially for larger applications.</p> <p>In Summary:</p> <ul> <li>Learn Node.js first: It\u2019s the foundational knowledge that will help you understand how Express works. You\u2019ll get a better grasp of the underlying JavaScript and asynchronous programming concepts.</li> <li>Learn Express afterward: Express simplifies common tasks in Node.js, like routing and middleware, and it makes backend development faster and more structured.</li> </ul>"},{"location":"api/","title":"API overview","text":""},{"location":"api/authentication/","title":"Authentication &amp; Authorization","text":""},{"location":"api/endpoints/","title":"List of API endpoints","text":""},{"location":"api/error-handling/","title":"Error handling and response codes","text":""},{"location":"api/rate-limiting/","title":"Rate limiting and throttling","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/","title":"\ud83e\udd14 Choosing the Right Backend Language and Framework","text":"","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#choosing-the-right-backend-language-and-framework","title":"\ud83e\udd14 Choosing the Right Backend Language and Framework","text":"<p>Not all languages and frameworks are built for the same purpose. The best backend stack depends on what you're building, who's building it, and how fast it needs to ship.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#the-core-question","title":"\ud83c\udfaf The Core Question","text":"<p>Instead of asking:</p> <p>\u201cWhat\u2019s the best backend language?\u201d</p> <p>Ask:</p> <p>\u201cWhat problem am I solving, and which tool fits it best?\u201d</p> <p>There\u2019s a huge difference between building a real-time chat app and a financial reporting engine. Let's break it down.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#what-youre-really-choosing","title":"\ud83d\udd27 What You\u2019re Really Choosing","text":"","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#language-the-core-technology","title":"\ud83e\udde0 Language = The core technology","text":"<p>Examples: Python, JavaScript/TypeScript, Go, Rust, Java, C#</p>","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#framework-the-web-scaffolding-in-that-language","title":"\u2699\ufe0f Framework = The web scaffolding in that language","text":"<p>Examples: FastAPI, Django, Express.js, NestJS, Spring Boot, .NET Core</p>","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#decision-factors","title":"\u2705 Decision Factors","text":"Criteria Why It Matters \ud83d\ude80 Performance Needed for real-time or high-traffic systems \ud83e\udde9 Ecosystem Libraries and integrations reduce time to build \ud83e\uddd1\u200d\ud83d\udcbb Team Skill Familiarity = faster dev and fewer bugs \ud83d\udee0 Tooling DevX, testing, IDE support matters long term \ud83e\uddea Maintainability Framework structure keeps code scalable \ud83c\udf0d Community Bigger community = easier troubleshooting","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#quick-comparison","title":"\ud83d\udcca Quick Comparison","text":"Stack Strengths Ideal For Cautions Python + FastAPI Async-ready, clean, great docs APIs, ML backends Slower than Go/Node Python + Django All-in-one, ORM, admin MVPs, internal tools Heavy, opinionated Node.js + Express Lightweight, flexible Real-time, quick APIs Unstructured Node.js + NestJS TypeScript-first, scalable Enterprise apps Verbose Go + Fiber Super fast, low memory High-scale APIs, infra Fewer libs, low-level Java + Spring Boot Enterprise-ready Banking, B2B systems Verbose, complex Rust + Axum Safe, fast, modern Edge, systems code Learning curve C# + ASP.NET Core Excellent tooling Enterprises, Windows Steeper startup for Linux teams","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#developer-centric-guide","title":"\ud83e\uddd1\u200d\ud83d\udcbb Developer-Centric Guide","text":"You Are\u2026 Recommended Stack Solo dev building MVP Django or FastAPI JavaScript/TypeScript expert NestJS Scaling to real-time Express or Go Enterprise backend team Spring Boot or .NET Startup using ML/NLP FastAPI Building CLI or infra Go Exploring low-latency systems Rust + Actix","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#summary-table","title":"\ud83d\udccc Summary Table","text":"Goal Language Framework Build APIs fast Python FastAPI Need full-featured web backend Python Django Real-time performance JavaScript or Go Express or Fiber Enterprise scale Java or C# Spring Boot or ASP.NET Core Maximum performance Rust or Go Axum or Fiber","tags":["Best Practices"]},{"location":"blog/2025/07/01/-choosing-the-right-backend-language-and-framework/#final-thoughts","title":"\ud83e\udde0 Final Thoughts","text":"<p>Don\u2019t chase trends \u2014 match your stack to your use case and team capability.</p> <p>\u2705 Think:</p> <ul> <li>What problem am I solving?</li> <li>What skills does my team already have?</li> <li>What trade-offs (speed vs ease) matter most?</li> </ul> <p>Choosing a backend stack isn't about hype \u2014 it's about pragmatism.</p> <p>\ud83d\udcda Related: Problem-Focused Observability</p>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/","title":"Choosing the Right Backend Framework for Your Use Case","text":"","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#choosing-the-right-backend-framework-for-your-use-case","title":"Choosing the Right Backend Framework for Your Use Case","text":"<p>There\u2019s no one-size-fits-all backend framework \u2014 and that\u2019s a good thing.</p> <p>Different teams, project types, and priorities call for different tools. Below is a practical guide to help you choose the right backend stack based on your goals, team composition, and project stage.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#what-should-you-use","title":"\ud83d\udd27 What Should You Use?","text":"You Are\u2026 Recommended Stack Solo dev building MVP Django or FastAPI JavaScript/TypeScript expert NestJS Scaling to real-time Express or Go Enterprise backend team Spring Boot or .NET Startup using ML/NLP FastAPI Building CLI or infra Go Exploring low-latency systems Rust + Actix","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#why-not-just-use-one-framework-for-all-apis","title":"\ud83e\udd14 Why Not Just Use One Framework for All APIs?","text":"<p>Because different problems require different trade-offs:</p> <ul> <li>\u26a1 Some need speed and performance</li> <li>\ud83d\udd12 Others require security and stability</li> <li>\ud83d\udee0 Some prioritize developer productivity</li> <li>\ud83c\udf10 And others need scalability, type safety, or async support</li> </ul> <p>Using the wrong tool can cost you time, performance, and maintainability.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#why-use-django-or-fastapi-for-solo-dev-mvps","title":"\ud83d\udcbb Why Use Django or FastAPI for Solo Dev MVPs?","text":"<ul> <li>Django comes batteries-included: ORM, auth, admin panel \u2014 great for CRUD-heavy apps or fast prototyping.</li> <li>FastAPI is lightweight, async-ready, and great when you want speed + flexibility. Ideal for modern APIs, ML serving, or async tasks.</li> </ul> <p>\u2705 Why it works for solo developers:</p> <ul> <li>Fast development cycle</li> <li>Low setup friction</li> <li>Large communities</li> <li>Easy to deploy (Heroku, Render, Docker)</li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#other-cases-explained","title":"\ud83e\udde0 Other Cases Explained","text":"","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#javascripttypescript-expert-nestjs","title":"JavaScript/TypeScript Expert \u2192 NestJS","text":"<p>If you're already deep in the JS/TS ecosystem, NestJS gives you a structured, opinionated framework similar to Angular. Great for teams that want decorators, DI, and a solid dev experience \u2014 without leaving TypeScript.</p>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#scaling-to-real-time-systems-express-or-go","title":"Scaling to Real-Time Systems \u2192 Express or Go","text":"<ul> <li>Express is minimal and battle-tested in Node.js environments.</li> <li>Go provides built-in concurrency and low-latency handling, perfect for WebSockets or event-driven backends.</li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#enterprise-backend-teams-spring-boot-or-net","title":"Enterprise Backend Teams \u2192 Spring Boot or .NET","text":"<ul> <li>These frameworks scale across teams, enforce structure, and integrate well with enterprise tooling (APM, security, DevOps).</li> <li>Used in finance, healthcare, telecom where standards and reliability are non-negotiable.</li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#mlnlp-startups-fastapi","title":"ML/NLP Startups \u2192 FastAPI","text":"<ul> <li>Built with Pydantic and type hints \u2014 perfect for serving ML models.</li> <li>Compatible with async I/O, model validation, OpenAPI docs out of the box.</li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#cli-or-infra-projects-go","title":"CLI or Infra Projects \u2192 Go","text":"<ul> <li>Go compiles to a single binary.</li> <li>Great performance, simple syntax, and static typing.</li> <li>Ideal for tools, CLIs, infrastructure, and APIs that demand speed and simplicity.</li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#low-latency-systems-rust-actix","title":"Low-Latency Systems \u2192 Rust + Actix","text":"<ul> <li>Rust offers memory safety without a GC.</li> <li>Actix is one of the fastest web frameworks available.</li> <li>Ideal when you\u2019re building systems that need ultra-low latency and full control over the stack.</li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/07/30/choosing-the-right-backend-framework-for-your-use-case/#final-thoughts","title":"\ud83e\udde9 Final Thoughts","text":"<p>Choosing a backend framework is like choosing a tool in a toolbox. You don\u2019t need a jackhammer to hang a picture.</p> <p>Pick what aligns with your team, goals, and constraints \u2014 not what\u2019s trending.</p> <p>Still unsure which framework is right for your use case? Feel free to reach out or explore some real-world examples in our upcoming guides.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/","title":"Do You Need Grafana and Prometheus as a FastAPI Developer?","text":"","tags":["Best Practices"]},{"location":"blog/2025/08/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#do-you-need-grafana-and-prometheus-as-a-fastapi-developer","title":"Do You Need Grafana and Prometheus as a FastAPI Developer?","text":"<p>As a FastAPI developer, you're probably focused on building fast, reliable APIs. But as your application grows, you\u2019ll start asking deeper questions like:</p> <ul> <li>How do I know my app is healthy?</li> <li>What happens if something fails in production?</li> <li>Should I use observability tools like Grafana and Prometheus?</li> </ul> <p>Let\u2019s explore this with clarity \u2014 and without the hype.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#first-what-do-grafana-and-prometheus-actually-do","title":"\ud83e\udd14 First, What Do Grafana and Prometheus Actually Do?","text":"<ul> <li>Prometheus is a monitoring system that collects metrics from your app (like request rates, latency, CPU usage).</li> <li>Grafana is a visualization tool that builds dashboards on top of those metrics, often from Prometheus.</li> </ul> <p>Together, they form a powerful observability stack \u2014 but they also add complexity.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#should-you-use-them-in-your-fastapi-project","title":"\ud83d\udea6 Should You Use Them in Your FastAPI Project?","text":"<p>Here\u2019s a practical rule of thumb:</p> Project Type Use Grafana + Prometheus? \ud83d\udd39 Personal / hobby project \u274c No \ud83d\udd39 MVP or early-stage app \u274c Not yet \ud83d\udd38 Production API with users \u26a0\ufe0f Maybe \ud83d\udd38 SaaS / scalable backend \u2705 Yes \ud83d\udd38 Microservices / DevOps team \u2705 Absolutely","tags":["Best Practices"]},{"location":"blog/2025/08/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#when-it-makes-sense","title":"\u2705 When It Makes Sense","text":"<p>Use Grafana + Prometheus when:</p> <ul> <li>You deploy to production</li> <li>You care about uptime, latency, or error rates</li> <li>You want to alert on failures or slow endpoints</li> <li>You have multiple services or infrastructure to monitor</li> </ul> <p>Example: Your API starts timing out randomly, but logs don\u2019t show anything. Metrics from Prometheus can reveal CPU spikes or slow queries in real time.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#when-its-overkill","title":"\u274c When It\u2019s Overkill","text":"<p>Skip Grafana + Prometheus if:</p> <ul> <li>You're building locally or just learning</li> <li>Your system is simple and has no uptime requirement</li> <li>You just need basic logging or debugging</li> </ul> <p>Instead, stick to:</p> <ul> <li><code>print()</code> or Python <code>logging</code></li> <li>FastAPI logs from Uvicorn</li> <li>Error monitoring (e.g. Sentry)</li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/08/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#a-lightweight-middle-ground","title":"\ud83d\udee0\ufe0f A Lightweight Middle Ground","text":"<p>You don\u2019t need the full stack to get started. Try this:</p> <ol> <li>Install the Prometheus FastAPI middleware:</li> </ol> <pre><code>pip install prometheus-fastapi-instrumentator\n</code></pre> <ol> <li>Add it to your app:</li> </ol> <pre><code>from fastapi import FastAPI\nfrom prometheus_fastapi_instrumentator import Instrumentator\n\napp = FastAPI()\nInstrumentator().instrument(app).expose(app)\n</code></pre> <ol> <li>Run Prometheus to scrape your app at <code>/metrics</code>.</li> <li>Optionally visualize it in Grafana.</li> </ol> <p>It\u2019s simple and gives you visibility without heavy setup.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/01/do-you-need-grafana-and-prometheus-as-a-fastapi-developer/#final-thought","title":"\ud83e\udde0 Final Thought","text":"<p>Don\u2019t adopt tools blindly. Prometheus and Grafana are not \"must-haves\" \u2014 they\u2019re \"power-tools\" for when monitoring becomes a problem to solve.</p> <p>Before integrating them, ask:</p> <p>What failure am I trying to prevent or detect?</p> <p>Only when the answer matters to your system\u2019s success, should you bring them in.</p> <p>\ud83d\udccc TL;DR</p> <ul> <li>\ud83d\udeab Don\u2019t use Grafana/Prometheus just because they\u2019re popular.</li> <li>\u2705 Use them if you need deep visibility into a production system.</li> <li>\u2696\ufe0f For small apps, consider lightweight metrics + logging first.</li> </ul> <p>Need help setting up minimal monitoring for your FastAPI app? Check out this minimal observability stack (Coming soon).</p>","tags":["Best Practices"]},{"location":"blog/2025/08/02/thinking-like-a-systems-designer/","title":"Thinking Like a Systems Designer","text":"","tags":["Best Practices"]},{"location":"blog/2025/08/02/thinking-like-a-systems-designer/#thinking-like-a-systems-designer","title":"Thinking Like a Systems Designer","text":"<p>Excellent \u2014 you're thinking like a real systems designer now.</p> <p>In the world of modern infrastructure and observability, it's easy to get caught up in shiny tools and industry trends. Prometheus, Loki, Tempo, Grafana \u2014 these names dominate the DevOps and SRE conversation. They\u2019re powerful, yes. But ask yourself:</p> <p>Why are you using them?</p> <p>Too often, teams adopt these tools because they\u2019re the standard, not because they\u2019re the solution.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/02/thinking-like-a-systems-designer/#start-with-the-problem-not-the-tool","title":"Start With the Problem, Not the Tool","text":"<p>A real systems designer doesn\u2019t start with tools. They start with the problem.</p> <ul> <li>What are we trying to observe?</li> <li>What kind of failures do we care about?</li> <li>How fast do we need to detect anomalies?</li> <li>Who needs to be alerted, and how actionable are those alerts?</li> </ul> <p>Until you can clearly articulate these, the choice of stack is secondary.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/02/thinking-like-a-systems-designer/#a-tool-is-only-as-good-as-the-use-case-it-solves","title":"A Tool is Only as Good as the Use Case It Solves","text":"<p>Consider this scenario:</p> <p>Your team sets up Grafana dashboards, alerts via Prometheus, tracing via Tempo\u2026 but nobody uses them. Alerts are noisy. Dashboards are rarely visited. Why? Because the why was never defined.</p> <p>Just because a stack is popular doesn't mean it's what your system or team needs.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/02/thinking-like-a-systems-designer/#shift-the-mindset","title":"Shift the Mindset","text":"<p>Here's how to shift from being a \"tool chaser\" to a real systems thinker:</p> <ol> <li>Define the pain clearly \u2014 \u201cWe miss incidents in staging,\u201d or \u201cWe get flooded with alerts during deploys.\u201d</li> <li>Map out the observability needs \u2014 Do you need logs? Metrics? Traces? Where is the blind spot?</li> <li>Select minimal tools to start \u2014 Tools should serve your insights, not create work.</li> <li>Evolve based on gaps, not trends \u2014 Only introduce new tools when your current stack can\u2019t handle a growing need.</li> </ol>","tags":["Best Practices"]},{"location":"blog/2025/08/02/thinking-like-a-systems-designer/#final-thought","title":"Final Thought","text":"<p>Systems design is not about using industry-standard tools. It's about building systems that are resilient, observable, and understandable.</p> <p>Tools come and go. Principles last.</p> <p>So the next time someone says, \u201cLet\u2019s use Prometheus,\u201d ask instead:</p> <p>\ud83d\udc49 \u201cWhat are we trying to measure, and why?\u201d</p> <p>\ud83e\udde0 Think like a systems designer. Solve problems. Then pick tools.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/","title":"\ud83d\udd0d Observability: Focus on the Problems, Not Just the Tools","text":"","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/#observability-focus-on-the-problems-not-just-the-tools","title":"\ud83d\udd0d Observability: Focus on the Problems, Not Just the Tools","text":"<p>Too many teams adopt Prometheus, Loki, Tempo, and Grafana because they\u2019re \u201cstandard.\u201d But real observability is about solving problems \u2014 not collecting data.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/#the-real-question","title":"\ud83e\udded The Real Question","text":"<p>When something goes wrong in production, you don\u2019t ask:</p> <p>\u201cWhich dashboard looks coolest?\u201d</p> <p>You ask:</p> <ul> <li>\u201cWhy is my FastAPI app slow right now?\u201d</li> <li>\u201cWhat caused all these 500 errors?\u201d</li> <li>\u201cIs our new deploy breaking something?\u201d</li> </ul> <p>If your tools can't help answer those questions quickly, you don't have observability \u2014 you have monitoring noise.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/#problem-first-thinking","title":"\ud83c\udfaf Problem-First Thinking","text":"<p>Let\u2019s flip the narrative. Instead of documenting tools like this:</p> <ul> <li>Prometheus: for metrics</li> <li>Loki: for logs</li> <li>Tempo: for traces</li> <li>Grafana: to visualize everything</li> </ul> <p>Try this instead:</p> \u2753 Problem \u2705 Solution \ud83d\udee0 Tool API is slow, but why? Show end-to-end request trace Tempo Requests are failing suddenly Find logs with errors around the spike Loki Need to alert on high error rates Alert when metrics exceed thresholds Prometheus Want everything in one place Correlate metrics, logs, traces Grafana","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/#stack-architecture-reframed","title":"\ud83e\udde0 Stack Architecture \u2014 Reframed","text":"","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/#traditional-view","title":"Traditional View:","text":"<p>A diagram showing all tools wired together.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/#problem-focused-view","title":"Problem-Focused View:","text":"<ul> <li> <p>\ud83d\udd27 Need: Know when something breaks   \u2192 Use Prometheus for metrics + alerts</p> </li> <li> <p>\ud83d\udd0d Need: Understand what broke and why   \u2192 Use Loki for log context + errors</p> </li> <li> <p>\u23f1\ufe0f Need: Track what happened during a request   \u2192 Use Tempo and OpenTelemetry for tracing</p> </li> <li> <p>\ud83d\udcca Need: Correlate and visualize everything   \u2192 Use Grafana as the central interface</p> </li> </ul>","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/#real-example-api-latency-spike","title":"\ud83d\udee0 Real Example: API Latency Spike","text":"<p>You see a latency spike on <code>/api/orders</code>.</p> <p>Here\u2019s how the stack helps:</p> <ol> <li>Prometheus shows the spike in response time</li> <li>Grafana alert fires, and you click the dashboard</li> <li>You follow a Tempo trace from that request</li> <li>Trace shows DB query took 1.2s \u2014 that\u2019s the bottleneck</li> <li>You jump into Loki logs by trace ID</li> <li>Error message confirms: <code>Missing index on orders.created_at</code></li> </ol> <p>\ud83d\udd01 Metrics \u2192 Trace \u2192 Logs \u2192 Resolution All in one flow, from a single alert.</p>","tags":["Best Practices"]},{"location":"blog/2025/08/03/-observability-focus-on-the-problems-not-just-the-tools/#takeaway","title":"\u2705 Takeaway","text":"<p>Don\u2019t build observability for the sake of having dashboards.</p> <p>Build it so when your app breaks at 2:14 AM, you know:</p> <ul> <li>What broke</li> <li>Why it broke</li> <li>Where to fix it</li> </ul> <p>That's what Prometheus, Loki, Tempo, and Grafana are for \u2014 when used right.</p> <p>\ud83d\udcda Learn More:</p>","tags":["Best Practices"]},{"location":"core/architecture/","title":"Architecture","text":""},{"location":"core/architecture/#system-architecture-overview","title":"System Architecture Overview","text":"<p>This section outlines the high-level architecture of the backend system. The backend is designed to be scalable, maintainable, and secure, supporting a variety of use cases while ensuring flexibility and performance.</p>"},{"location":"core/architecture/#architecture-diagram","title":"Architecture Diagram","text":"<p>Note: Replace with your actual architecture diagram.</p>"},{"location":"core/architecture/#components","title":"Components","text":""},{"location":"core/architecture/#1-client-frontend","title":"1. Client (Frontend)","text":"<p>The client-side (browser, mobile app, or other service) communicates with the backend via a RESTful API or GraphQL (depending on the use case). The client handles the user interface and interaction, sending requests to the backend for data and receiving responses to update the UI.</p>"},{"location":"core/architecture/#2-api-gateway","title":"2. API Gateway","text":"<p>The API Gateway acts as the entry point for all incoming requests from the client. It handles routing, authentication, rate-limiting, and sometimes caching of requests to backend services. It may also handle load balancing if multiple backend services are deployed.</p> <p>Responsibilities:</p> <ul> <li>Authenticate and authorize requests.</li> <li>Route requests to the appropriate backend service.</li> <li>Perform rate-limiting and security checks.</li> </ul>"},{"location":"core/architecture/#3-authentication-authorization-service","title":"3. Authentication &amp; Authorization Service","text":"<p>This service manages user authentication, session management, and authorization. It verifies the identity of users and generates JWT tokens or OAuth tokens for secure communication between the client and backend.</p> <p>Responsibilities:</p> <ul> <li>Authenticate users (login, logout).</li> <li>Issue and verify tokens (JWT, OAuth).</li> <li>Provide user roles and permissions.</li> </ul>"},{"location":"core/architecture/#4-core-backend-services","title":"4. Core Backend Services","text":"<p>These are the core services that handle business logic, data processing, and serve API requests. The backend is typically divided into different services, each responsible for a specific set of operations (e.g., user management, product management, payment processing, etc.).</p> <p>Service Layer:</p> <ul> <li>Each backend service can be either monolithic or microservices-based.</li> <li>Microservices may interact with each other via REST or gRPC.</li> <li>The services are stateless and can be scaled independently.</li> </ul>"},{"location":"core/architecture/#5-database-layer","title":"5. Database Layer","text":"<p>The database stores all persistent data, such as user information, transactional data, and application state. The choice of database may vary depending on the project needs.</p> <p>Relational Database (SQL) Example:</p> <ul> <li>PostgreSQL, MySQL, or similar.</li> <li>Stores structured data with relationships between entities (e.g., users, products).</li> </ul> <p>NoSQL Database Example:</p> <ul> <li>MongoDB, Redis, etc., for flexible schema or caching purposes.</li> </ul> <p>Responsibilities:</p> <ul> <li>Handle CRUD operations for entities.</li> <li>Manage relationships and schema consistency.</li> <li>Ensure data integrity and durability.</li> </ul>"},{"location":"core/architecture/#6-caching-layer","title":"6. Caching Layer","text":"<p>Caching is used to store frequently accessed data in-memory to reduce database load and speed up response times. Common tools include Redis or Memcached.</p> <p>Responsibilities:</p> <ul> <li>Cache common query results (e.g., product data, user sessions).</li> <li>Improve read performance by reducing database load.</li> </ul>"},{"location":"core/architecture/#7-queuemessage-broker","title":"7. Queue/Message Broker","text":"<p>In a microservices or distributed architecture, a message queue or broker (e.g., RabbitMQ, Kafka) facilitates asynchronous communication between services, decoupling the services and enabling event-driven architecture.</p> <p>Responsibilities:</p> <ul> <li>Process long-running tasks asynchronously (e.g., email notifications, image processing).</li> <li>Ensure services are loosely coupled and resilient.</li> </ul>"},{"location":"core/architecture/#8-monitoring-and-logging","title":"8. Monitoring and Logging","text":"<p>Monitoring tools (e.g., Prometheus, Grafana) and centralized logging systems (e.g., ELK Stack, Splunk) are essential for tracking the performance, availability, and errors in the backend system.</p> <p>Responsibilities:</p> <ul> <li>Collect metrics on request latency, error rates, and system health.</li> <li>Aggregate logs for debugging and auditing.</li> <li>Send alerts for abnormal system behavior.</li> </ul>"},{"location":"core/architecture/#9-cicd-pipeline","title":"9. CI/CD Pipeline","text":"<p>Continuous Integration and Continuous Deployment (CI/CD) automates the build, testing, and deployment process. Tools like Jenkins, GitLab CI, or GitHub Actions ensure that code changes are automatically tested and deployed to production with minimal human intervention.</p> <p>Responsibilities:</p> <ul> <li>Automate code quality checks (linting, unit tests).</li> <li>Deploy to staging and production environments.</li> <li>Rollback deployments if issues occur.</li> </ul>"},{"location":"core/architecture/#deployment-architecture","title":"Deployment Architecture","text":""},{"location":"core/architecture/#1-containerization-docker","title":"1. Containerization (Docker)","text":"<p>The backend services are containerized using Docker to ensure consistent environments across development, staging, and production. This also simplifies scaling and deployment.</p>"},{"location":"core/architecture/#2-orchestration-kubernetes","title":"2. Orchestration (Kubernetes)","text":"<p>Kubernetes is used for orchestrating and managing containerized services. It provides features like auto-scaling, self-healing, and load balancing.</p>"},{"location":"core/architecture/#3-cloud-infrastructure-aws-gcp-azure","title":"3. Cloud Infrastructure (AWS, GCP, Azure)","text":"<p>The backend is deployed on cloud infrastructure to provide scalability, redundancy, and high availability. The cloud provider may offer additional services like managed databases, caching, and message queues.</p> <p>Responsibilities:</p> <ul> <li>Automate scaling based on traffic load.</li> <li>Ensure fault tolerance and disaster recovery.</li> </ul>"},{"location":"core/architecture/#summary","title":"Summary","text":"<p>The backend architecture is designed for scalability, resilience, and performance. By splitting the system into manageable components and services, we ensure that each part of the system can be developed, tested, and deployed independently. This architecture is adaptable to various backend frameworks and technologies, and it supports a wide range of client applications.</p> <p>For detailed specifications of each component, see the corresponding documentation sections:</p> <ul> <li>API Documentation</li> <li>Database Schema</li> <li>Deployment Guide</li> </ul>"},{"location":"core/bff/intro/","title":"Intro","text":"<p>The Backends for Frontends (BFF) pattern is an architectural pattern that involves creating a separate backend service for each frontend application. This pattern is often used in microservices architectures, where each service is responsible for a specific function.</p> <p></p> <p></p>"},{"location":"core/bff/intro/#what-is-backend-for-frontend-bff","title":"What is Backend for Frontend (BFF)?","text":"<p>Backend for Frontend (BFF) is a design pattern that involves creating a dedicated backend service tailored specifically for a particular frontend application (like a web or mobile app). This approach helps in optimizing the communication between the frontend and backend by providing a layer that is specifically designed to serve the needs of the frontend, making it easier to manage and improve performance.</p>"},{"location":"core/bff/intro/#overview","title":"Overview","text":"<p>Backend for Frontend (BFF) is designed to create a dedicated backend layer tailored specifically for individual frontend applications. It serves to optimize communication, improve performance, and streamline development by providing APIs that are custom-built to meet the specific needs of each frontend.</p>"},{"location":"core/bff/intro/#key-features-of-bff","title":"Key Features of BFF","text":"<ol> <li>Tailored API: Each frontend (web, mobile, etc.) can have its own backend that serves only the data and functionality it needs.</li> <li>Reduced Over-fetching: By designing the API specifically for the frontend, you can avoid sending unnecessary data, reducing payload sizes.</li> <li>Simplified Logic: It allows for frontend-specific logic to reside in the backend, keeping the frontend code cleaner and more focused on presentation.</li> <li>Easier Adaptation: Changes in the frontend can often be accommodated in the BFF without affecting the overall backend architecture.</li> </ol>"},{"location":"core/bff/intro/#scenario","title":"Scenario","text":"With BFFWithout BFFSummary <p>Suppose you have two different frontend applications: a web app and a mobile app. Each of these apps requires different data formats and structures from the backend.</p> <ul> <li>Web App: Needs detailed information, including user profiles, order histories, and recommendations.</li> <li>Mobile App: Needs summarized data to save bandwidth, focusing only on essential information like user profiles and recent orders.</li> </ul> BFF Implementation <p>BFF Layer:</p> <ul> <li> <p>Web BFF:</p> <ul> <li>API Endpoint: <code>/api/web/user-profile</code></li> <li>Returns detailed user information, including nested objects.</li> </ul> </li> <li> <p>Mobile BFF:</p> <ul> <li>API Endpoint: <code>/api/mobile/user-profile</code></li> <li>Returns a simplified version of the user profile with only essential fields.</li> </ul> </li> </ul> <p>Benefits:</p> <ul> <li>Tailored Responses: Each frontend gets exactly what it needs without over-fetching or under-fetching data.</li> <li>Decoupled Development: Frontend teams can work independently from backend teams since the BFF layer abstracts the backend complexities.</li> <li>Optimized Performance: By reducing payload sizes for the mobile app, you improve loading times and user experience.</li> </ul> <p>In a traditional setup, you might have a single backend service that serves both the web and mobile apps.</p> <ul> <li> <p>Single API Endpoint: <code>/api/user-profile</code></p> <ul> <li>Returns all user data regardless of the frontend requesting it, including detailed information that the mobile app doesn't need.</li> </ul> </li> </ul> Drawbacks: <ul> <li>Over-fetching: The mobile app receives more data than it needs, leading to larger payloads and slower response times.</li> <li>Inflexibility: Any changes required for one frontend can inadvertently affect the other, making development less agile.</li> <li>Complexity: Frontend developers may need to implement additional logic to filter and process unnecessary data, adding to their workload.</li> </ul> <p>Using a BFF allows you to tailor backend services specifically for different frontend applications, optimizing data delivery, improving performance, and simplifying development. In contrast, a traditional single-backend approach can lead to inefficiencies and complexities as frontends evolve.</p>"},{"location":"core/bff/intro/#implementation-in-drf","title":"Implementation in drf","text":""},{"location":"core/bff/intro/#is-bff-a-microservice","title":"Is BFF a Microservice?","text":"<p>Yes, the Backend For Frontend pattern is one of several types of microservice architecture patterns.</p> <p>Each BFF service is considered a microservice that serves as a connector between frontend and backend development.</p>"},{"location":"core/bff/intro/#reference","title":"Reference","text":"<ul> <li>Backend for Frontend: Understanding the Pattern to Unlock Its Power</li> <li>Backends for Frontends (BFF) Pattern: Architectural Patterns</li> <li>Why \u201cBackend For Frontend\u201d Application Architecture?</li> <li>Backends For Frontends \u2014 My Take</li> </ul>"},{"location":"core/bff/question/","title":"Question","text":""},{"location":"core/bff/question/#question","title":"Question","text":"<p>What is required to implement a Backend for Frontend (BFF) architecture in Django with Django REST Framework (DRF)?</p> <p>To implement a BFF architecture in Django and DRF, you generally need to focus on the following key components:</p> <ol> <li> <p>Custom Serializers:</p> <ul> <li>You will need to create different serializers for each frontend application (e.g., web and mobile) to tailor the data structure according to their specific needs.</li> </ul> </li> <li> <p>Viewsets:</p> <ul> <li>Create separate viewsets for each frontend, using the custom serializers to handle requests and responses appropriately.</li> </ul> </li> <li> <p>URLs:</p> <ul> <li>Set up distinct URL routes for each BFF endpoint, ensuring that each frontend can access its corresponding API.</li> </ul> </li> <li> <p>Data Models (if applicable):</p> <ul> <li>Your data models may remain the same, but the way you serve them will differ based on the serializers and viewsets you create.</li> </ul> </li> <li> <p>Authentication and Permissions (if needed):</p> <ul> <li>You may also want to implement different authentication or permission schemes based on the frontend requirements.</li> </ul> </li> </ol> <p>Summary</p> <p>While customizing serializers is a significant part of implementing a BFF, it\u2019s not the only step. You also need to create dedicated viewsets and URL configurations to ensure each frontend receives the data in the format it requires.</p>"},{"location":"core/bff/question/#step-by-step-example","title":"Step-by-Step Example","text":"Basic Example <ol> <li> <p>Set Up Your Django Project</p> <p>First, create a new Django project and an app:</p> <pre><code>django-admin startproject my_bff\ncd my_bff\ndjango-admin startapp user\n</code></pre> </li> <li> <p>Install Django REST Framework</p> <p>Install DRF:</p> <pre><code>pip install djangorestframework\n</code></pre> <p>Add <code>'rest_framework'</code> and your app (<code>'user'</code>) to <code>INSTALLED_APPS</code> in <code>settings.py</code>:</p> <pre><code># my_bff/settings.py\n\nINSTALLED_APPS = [\n    ...\n    'rest_framework',\n    'user',\n]\n</code></pre> </li> <li> <p>Create the User Model</p> <p>Define a simple User model in <code>models.py</code>:</p> <pre><code># user/models.py\n\nfrom django.db import models\n\nclass User(models.Model):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    phone = models.CharField(max_length=15)\n    street = models.CharField(max_length=255)\n    city = models.CharField(max_length=100)\n    zipcode = models.CharField(max_length=10)\n    newsletter = models.BooleanField(default=False)\n    notifications = models.BooleanField(default=False)\n\n    def __str__(self):\n        return self.username\n</code></pre> <p>Run the migrations to create the User table:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> </li> <li> <p>Create Serializers</p> <p>Create serializers for the User model in <code>serializers.py</code>:</p> <pre><code># user/serializers.py\n\nfrom rest_framework import serializers\nfrom .models import User\n\nclass UserProfileWebSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email', 'phone', 'street', 'city', 'zipcode', 'newsletter', 'notifications']\n\nclass UserProfileMobileSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email']\n</code></pre> </li> <li> <p>Create Viewsets</p> <p>Define viewsets for the different BFFs in <code>views.py</code>:</p> <pre><code># user/views.py\n\nfrom rest_framework import viewsets\nfrom .models import User\nfrom .serializers import UserProfileWebSerializer, UserProfileMobileSerializer\n\nclass UserProfileWebViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserProfileWebSerializer\n\nclass UserProfileMobileViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserProfileMobileSerializer\n</code></pre> </li> <li> <p>Configure URLs</p> <p>Set up URLs for the two different BFFs in <code>urls.py</code>:</p> <pre><code># user/urls.py\n\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import UserProfileWebViewSet, UserProfileMobileViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'web/user-profile', UserProfileWebViewSet, basename='user-web')\nrouter.register(r'mobile/user-profile', UserProfileMobileViewSet, basename='user-mobile')\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre> <p>Include the user app URLs in the main project <code>urls.py</code>:</p> <pre><code># my_bff/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('api/', include('user.urls')),\n]\n</code></pre> </li> <li> <p>Test the BFF APIs</p> <p>Run your Django server:</p> <pre><code>python manage.py runserver\n</code></pre> </li> </ol>"},{"location":"core/bff/question/#endpoint","title":"Endpoint","text":"<p>Now, you can test the endpoints using a tool like <code>Postman</code> or <code>curl</code>.</p> 1. Web App Endpoint:2. Mobile App Endpoint: <ul> <li>URL: <code>http://localhost:8000/api/web/user-profile/</code></li> <li> <p>Response Example:</p> <pre><code>{\n    \"id\": 1,\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\",\n    \"phone\": \"123-456-7890\",\n    \"street\": \"123 Elm St\",\n    \"city\": \"Somewhere\",\n    \"zipcode\": \"12345\",\n    \"newsletter\": true,\n    \"notifications\": false\n}\n</code></pre> </li> </ul> <ul> <li>URL: <code>http://localhost:8000/api/mobile/user-profile/</code></li> <li> <p>Response Example:</p> <pre><code>{\n    \"id\": 1,\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\"\n}\n</code></pre> </li> </ul> Benefits of Using BFF <ol> <li> <p>Tailored Responses:</p> <ul> <li>The web app receives all necessary details, while the mobile app only gets the crucial information it needs.</li> </ul> </li> <li> <p>Reduced Payload:</p> <ul> <li>The mobile app's response is smaller, improving load times and performance.</li> </ul> </li> <li> <p>Decoupled Development:</p> <ul> <li>Frontend teams can make changes to their BFFs independently without affecting the other frontend.</li> </ul> </li> </ol> <p>Conclusion</p> <p>In this example, we implemented a BFF architecture using Django and Django REST Framework. We created two separate APIs tailored for different frontends (web and mobile), showcasing how to customize serializers, viewsets, and URLs to meet the specific needs of each frontend application. This approach optimizes data delivery and enhances performance, making it a great architectural choice.</p>"},{"location":"database/","title":"Overview","text":"<p>api</p>"},{"location":"database/migrations/","title":"Migration guide","text":""},{"location":"database/relationships/","title":"Entity relationships (ERD)","text":""},{"location":"database/schema/","title":"Database schema","text":""},{"location":"deployment/","title":"Overview","text":"<p>api</p>"},{"location":"deployment/ci-cd/","title":"CI/CD setup","text":""},{"location":"deployment/docker/","title":"Docker setup","text":""},{"location":"framework/nodejs/guide/","title":"Guide","text":""},{"location":"framework/nodejs/guide/#guide","title":"Guide","text":""},{"location":"framework/nodejs/guide/#tech-stack","title":"Tech Stack","text":"<p>For this simple CRUD API, the recommended tech stack is:</p> <ol> <li> <p>Backend Framework: Node.js with Express.js</p> <p>Lightweight and easy to use for building REST APIs.</p> </li> <li> <p>Database: PostgreSQL</p> <p>Structured and relational, ideal for handling amount and date data.</p> </li> <li> <p>ORM: Sequelize</p> <p>Simplifies database interactions with PostgreSQL.</p> </li> <li> <p>ontainerization: Docker</p> <p>Ensures portability and ease of deployment.</p> </li> </ol>"},{"location":"framework/nodejs/guide/#folder-structure-backend-only","title":"Folder Structure (Backend Only)","text":"<p>In this setup, you will have a backend-only project that exposes the API, and the React frontend (which will be in a separate project) will consume these APIs.</p> <pre><code>/my-app\n  /server                  # Backend (Node.js with Express and MongoDB)\n    /controllers           # API endpoint controllers\n    /models                # Mongoose models\n    /routes                # API routes\n    /config                # Database configuration\n    server.js              # Main entry point of the backend server\n    package.json           # Backend dependencies\n    .env                   # Environment variables (e.g., MongoDB URI)\n  README.md                # Project description\n</code></pre> <pre><code>- src/\n  - models/\n    - record.model.js\n  - routes/\n    - record.routes.js\n  - controllers/\n    - record.controller.js\n  - config/\n    - db.config.js\n  - server.js\n- Dockerfile\n- docker-compose.yml\n</code></pre>"},{"location":"framework/nodejs/guide/#backend-setup","title":"Backend Setup","text":""},{"location":"framework/nodejs/guide/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Go to the backend directory (<code>/server</code>) and initialize the project with:</p> <pre><code>cd /server\nnpm init -y\nnpm install express mongoose cors dotenv\n</code></pre>"},{"location":"framework/nodejs/guide/#2-folder-structure-and-backend-code","title":"2. Folder Structure and Backend Code","text":"<ul> <li>server.js: Entry point for the Express server.</li> <li>controllers/recordController.js: Controller logic for CRUD operations.</li> <li>models/Record.js: Mongoose schema for records.</li> <li>routes/recordRoutes.js: Define API routes.</li> </ul>"},{"location":"framework/nodejs/guide/#7-running-the-backend","title":"7. Running the Backend","text":"<pre><code>node server.js\n</code></pre>"},{"location":"framework/nodejs/guide/#code","title":"CODE","text":"<ol> <li> <p>Database Configuration (<code>src/config/db.config.js</code>)</p> <pre><code>const { Sequelize } = require(\"sequelize\");\n\nconst sequelize = new Sequelize(\"crud_db\", \"postgres\", \"password\", {\n  host: \"localhost\",\n  dialect: \"postgres\",\n});\n\nmodule.exports = sequelize;\n</code></pre> </li> <li> <p>Model Definition (<code>src/models/record.model.js</code>)</p> <pre><code>const { DataTypes } = require(\"sequelize\");\nconst sequelize = require(\"../config/db.config\");\n\nconst Record = sequelize.define(\"Record\", {\n  amount: {\n    type: DataTypes.FLOAT,\n    allowNull: false,\n  },\n  date: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n});\n\nmodule.exports = Record;\n</code></pre> </li> <li> <p>Controller (<code>src/controllers/record.controller.js</code>)</p> <pre><code>const Record = require(\"../models/record.model\");\n\n// Create a new record\nexports.createRecord = async (req, res) =&gt; {\n  try {\n    const { amount, date } = req.body;\n    const record = await Record.create({ amount, date });\n    res.status(201).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Get all records\nexports.getRecords = async (req, res) =&gt; {\n  try {\n    const records = await Record.findAll();\n    res.status(200).json(records);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Get a single record by ID\nexports.getRecordById = async (req, res) =&gt; {\n  try {\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n    res.status(200).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Update a record by ID\nexports.updateRecord = async (req, res) =&gt; {\n  try {\n    const { amount, date } = req.body;\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n\n    record.amount = amount;\n    record.date = date;\n    await record.save();\n\n    res.status(200).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Delete a record by ID\nexports.deleteRecord = async (req, res) =&gt; {\n  try {\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n\n    await record.destroy();\n\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n</code></pre> </li> <li> <p>Routes (<code>src/routes/record.routes.js</code>)</p> <pre><code>const express = require(\"express\");\nconst router = express.Router();\nconst controller = require(\"../controllers/record.controller\");\n\nrouter.post(\"/\", controller.createRecord);\nrouter.get(\"/\", controller.getRecords);\nrouter.get(\"/:id\", controller.getRecordById);\nrouter.put(\"/:id\", controller.updateRecord);\nrouter.delete(\"/:id\", controller.deleteRecord);\n\nmodule.exports = router;\n</code></pre> </li> <li> <p>Server Setup (<code>src/server.js</code>)</p> <pre><code>const express = require(\"express\");\nconst sequelize = require(\"./config/db.config\");\nconst recordRoutes = require(\"./routes/record.routes\");\n\nconst app = express();\napp.use(express.json());\n\n// Routes\napp.use(\"/api/records\", recordRoutes);\n\n// Start server and connect to DB\nsequelize\n  .sync()\n  .then(() =&gt; {\n    console.log(\"Database connected!\");\n    app.listen(3000, () =&gt; console.log(\"Server running on port 3000\"));\n  })\n  .catch((err) =&gt; console.error(\"Database connection failed:\", err));\n</code></pre> </li> <li> <p>Dockerfile</p> <pre><code>FROM node:16\n\nWORKDIR /app\n\nCOPY package.json package-lock.json ./\nRUN npm install\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [\"node\", \"src/server.js\"]\n</code></pre> </li> <li> <p>Docker Compose (<code>docker-compose.yml</code>)</p> <pre><code>version: \"3.8\"\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - db\n\n  db:\n    image: postgres:latest\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: crud_db\n    ports:\n      - \"5432:5432\"\n</code></pre> </li> </ol> How to Run <ol> <li> <p>Build and start the services:</p> <pre><code>docker-compose up --build\n</code></pre> </li> <li> <p>Access the API at <code>http://localhost:3000/api/records</code>.</p> </li> </ol> <p>This setup provides a fully functional CRUD API using Node.js, Express, PostgreSQL, Sequelize, and Docker</p>"},{"location":"framework/nodejs/guide/#extra","title":"Extra","text":""},{"location":"framework/nodejs/guide/#database","title":"DATABASE","text":"<pre><code>CREATE DATABASE testdb;\n\\list\n# or\n\\l\n# is same\n</code></pre>"},{"location":"framework/nodejs/guide/#listing-users-in-postgresql","title":"Listing users in PostgreSQL","text":"<p>Using the <code>\\du</code> Command</p> <ul> <li>The simplest way to list all users is by using the <code>\\du</code> command in the psql terminal.</li> <li>This will show a list of all roles in the database, including users, their attributes (such as superuser status), and their assigned roles.</li> </ul> <pre><code>\\du\n</code></pre> <p>This will display a table with the following columns:</p> <ul> <li>Role Name: The name of the user or role.</li> <li>Attributes: Whether the role is a superuser, can create databases, or has login privileges.</li> <li>Member Of: Any other roles this user belongs to.</li> </ul>"},{"location":"framework/nodejs/guide/#list-of-roles","title":"List of Roles","text":"Role name Attributes Member of postgres Superuser, Create role, Create DB, Replication, Bypass RLS {} bishow Create DB {} myuser Create DB {postgres}"},{"location":"framework/nodejs/guide/#to-check-if-user-has-password-or-not","title":"To Check if user has password or not","text":"<p>To check if a PostgreSQL user (like <code>bishow</code>) has a password set, you can query the pg_shadow system catalog table, which stores user information including the password hash (if set).</p> <ol> <li> <p>Querying the <code>pg_shadow</code> Table</p> <p>The <code>pg_shadow</code> table contains user information, including password data. To check if the user <code>bishow</code> has a password set, you can run the following query:</p> <pre><code>SELECT usename, passwd FROM pg_shadow WHERE usename = 'bishow';\n</code></pre> <ul> <li><code>usename</code>: The username.</li> <li><code>passwd</code>: The hashed password (if set) or an empty string if no password is set.</li> </ul> </li> </ol>"},{"location":"framework/nodejs/guide/#switch-user-to-login","title":"Switch User to Login","text":"<p>When you run the command:</p> <pre><code>sudo -u postgres psql\n</code></pre> <p>You are switching to the <code>postgres</code> user and logging into the PostgreSQL database as the <code>postgres</code> user (which is typically the superuser for PostgreSQL). Here's a breakdown:</p> <ul> <li> <p><code>sudo -u postgres</code>: This part of the command tells <code>sudo</code> to run the following command (<code>psql</code>) as the <code>postgres</code> user, which is usually the default superuser in PostgreSQL.</p> </li> <li> <p><code>psql</code>: This is the PostgreSQL interactive terminal that connects to the database.</p> </li> </ul> <p>Once you're inside the psql terminal, you'll be logged in as the <code>postgres</code> PostgreSQL user, not as your system's current user (e.g., <code>bishow</code> or any other user you might have logged in as on the operating system).</p> <p>To verify this inside the PostgreSQL terminal, you can run the following SQL command:</p> <pre><code>SELECT current_user;\n</code></pre> <p>This will return the PostgreSQL user you're currently logged in as.</p> <pre><code>postgres=# SELECT current_user;\n current_user\n--------------\n postgres\n(1 row)\n</code></pre> <p>In this example, the current PostgreSQL user is <code>postgres</code>.</p>"},{"location":"framework/nodejs/history/","title":"History","text":"<p>Node.js was initially developed by Ryan Dahl. He took the V8 JavaScript engine from Google\u2019s Chrome browser, added some APIs, wrapped it in an event loop, and launched it as an open-source product on Linux and macOS in 2009. The Windows edition arrived in 2011.</p> <p>The Node Package Manager (npm) was introduced in <code>2010</code>. It allowed developers to use code modules published by others in their own projects. There was no official ECMAScript module standard at the time, so Node.js and npm adopted CommonJS.</p> <p><code>Node.js: Novice to Ninja by SitePoint</code></p> <p>Node.js allows a developer with frontend JavaScript knowledge to leverage their skills on the backend.</p>"},{"location":"framework/nodejs/history/#node-version-manager","title":"Node Version Manager","text":"<p>Node Version Manager (nvm) is a tool that allows multiple editions of Node.js to be installed on the same Linux, macOS, or Windows WSL system. This can be practical if you\u2019re working on two or more projects using different versions of Node.js</p>"},{"location":"framework/nodejs/history/#choosing-a-nodejs-version","title":"Choosing a Node.js Version","text":"<p>Install a recent release of Node.js unless you\u2019re supporting a legacy application with specific requirements.</p> <p>Even-numbered Node.js versions \u2014 such as <code>16</code>, <code>18</code>, and <code>20</code> \u2014 focus on stability and security with long-term support (LTS). Updates are provided for at least two years, so I recommend them for live production servers. You should install an identical version on your development machine.</p> <p>Odd-numbered versions \u2014 such as <code>15</code>, <code>17</code>, <code>19</code> \u2014 are under active development and may have experimental features. They\u2019re fine for development if you\u2019re learning, experimenting, or upgrading frequently.</p>"},{"location":"framework/nodejs/overview/","title":"Overview","text":"<p>Node.js is a JavaScript runtime, which means it runs programs written in JavaScript. (1)</p> <ol> <li> Node.js: Novice to Ninja by SitePoint</li> </ol> <p>Node.js\u2014JavaScript code execution environment outside the browser. This platform allows you to write server-side code for dynamic web pages and web applications, as well as for command-line programs. (1)</p> <ol> <li> <code>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr, pg-11</code>. Using Node.js implements the \u201cJavaScript for everything\u201d paradigm. It involves using a single programming language to develop web applications instead of using different languages to work on the frontend and backend. Node.js is a server platform for working with JavaScript through the V8 engine.</li> </ol> <p>Node.js is very closely related to JavaScript, the syntax and architectural approaches are identical, only the \u201cbindings\u201d (browser and server) differ. (1)</p> <ol> <li> <code>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr, pg-33</code>.</li> </ol>"},{"location":"framework/nodejs/overview/#main-features-of-nodejs","title":"Main Features of Node.js","text":"<ul> <li>Speed</li> <li>Simplicity</li> <li>JavaScript</li> <li>V8 Engine</li> <li>Asynchrony</li> <li>Libraries</li> </ul>"},{"location":"framework/nodejs/overview/#best-use-cases","title":"Best Use Cases","text":"<ol> <li>Real-time applications:</li> <li>Low learning curve:</li> <li>Performance and scalability:</li> <li>NPM support with rich modules:</li> <li>A useful unified code base:</li> <li>Data streaming:</li> <li>Well suited for creating microservices:</li> <li>Strong corporate support:</li> </ol>"},{"location":"framework/nodejs/overview/#books","title":"Books","text":"<ul> <li>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr</li> </ul>"},{"location":"testing/","title":"Overview","text":"<p>api</p>"},{"location":"testing/integration-testing/","title":"Integration testing setup","text":""},{"location":"testing/test-coverage/","title":"Test coverage report","text":""},{"location":"testing/unit-testing/","title":"Unit testing guidelines","text":""},{"location":"tools/overview/","title":"Overview","text":""},{"location":"tools/overview/#backend-tools","title":"Backend Tools","text":""},{"location":"tools/overview/#high-level-roles","title":"\ud83d\udd01 High-Level Roles","text":"<ul> <li>Prometheus: A monitoring and alerting toolkit. It collects, stores, and queries metrics from your applications.</li> <li>Grafana: A visualization and dashboard tool. It connects to Prometheus and displays the metrics.</li> </ul> <p>So the order is:</p> <p>Prometheus first, then Grafana.</p>"},{"location":"tools/overview/#what-to-learn-first","title":"What to Learn First","text":""},{"location":"tools/overview/#1-prometheus-basics","title":"\ud83d\udccc 1. Prometheus Basics","text":"<p>Learn this first, because Grafana depends on Prometheus as a data source.</p> Key Concepts <ul> <li>Metrics format (key-value pairs, usually pulled from <code>/metrics</code>)</li> <li>How Prometheus scrapes targets (your FastAPI app)</li> <li>PromQL: Prometheus Query Language</li> <li>Configuration (<code>prometheus.yml</code>)</li> <li>How to expose metrics from FastAPI (using <code>prometheus_client</code>)</li> </ul> Example metric from FastAPI<pre><code>from prometheus_client import start_http_server, Counter\n\nREQUEST_COUNT = Counter('http_requests_total', 'Total HTTP Requests')\n\n@app.middleware(\"http\")\nasync def count_requests(request: Request, call_next):\n    REQUEST_COUNT.inc()\n    return await call_next(request)\n</code></pre> <p>Then Prometheus scrapes <code>http://&lt;your-app&gt;:8000/metrics</code>.</p>"},{"location":"tools/overview/#2-grafana-basics","title":"\ud83d\udccc 2. Grafana Basics","text":"<p>Once Prometheus is collecting metrics:</p> <ul> <li>Add Prometheus as a data source in Grafana.</li> <li> <p>Create dashboards using:</p> </li> <li> <p>Graphs (time series)</p> </li> <li>Gauges</li> <li>Tables</li> </ul> <p>You can use built-in dashboards or import community ones from Grafana Dashboards.</p>"},{"location":"tools/overview/#local-testing","title":"\ud83d\udd27 Local Testing","text":"<p>You can visit:</p> <ul> <li>Prometheus UI: <code>http://localhost:9090</code></li> </ul> <p>Try simple PromQL queries like:</p> <pre><code>http_requests_total\nrate(http_requests_total[1m])\n</code></pre> <ul> <li>Grafana UI: <code>http://localhost:3000</code></li> </ul> <p>Default login is <code>admin / admin</code>.</p>"},{"location":"tools/overview/#recommended-learning-path","title":"\ud83d\udee0 Recommended Learning Path","text":"<ol> <li> <p>Prometheus:</p> <ul> <li>Learn about scraping targets</li> <li>Learn PromQL basics</li> <li>Understand how metrics are collected</li> </ul> </li> <li> <p>Grafana:</p> <ul> <li>Learn dashboard creation</li> <li>Set up alerts</li> <li>Explore panel types</li> </ul> </li> </ol>"},{"location":"tools/overview/#resources","title":"\ud83d\udcda Resources","text":"<ul> <li>Prometheus Docs</li> <li>Grafana Docs</li> <li>FastAPI Monitoring with Prometheus</li> </ul>"},{"location":"tools/grafana/overview/","title":"Overview","text":""},{"location":"tools/grafana/setup/","title":"Setup","text":""},{"location":"tools/grafana/setup/#setup","title":"Setup","text":""},{"location":"tools/grafana/setup/#set-up-grafana-prometheus-docker","title":"Set Up Grafana + Prometheus (Docker)","text":""},{"location":"tools/grafana/setup/#docker-composeyml","title":"<code>docker-compose.yml</code>","text":"docker-compose.yml<pre><code>version: \"3\"\n\nservices:\n  prometheus:\n    image: prom/prometheus\n    volumes:\n      - ./prometheus.yml:/etc/prometheus/prometheus.yml\n    ports:\n      - \"9090:9090\"\n\n  grafana:\n    image: grafana/grafana\n    ports:\n      - \"3000:3000\"\n\n  fastapi:\n    build: .\n    ports:\n      - \"8000:8000\"\n</code></pre>"},{"location":"tools/grafana/setup/#prometheusyml","title":"prometheus.yml","text":"prometheus.yml<pre><code>global:\n  scrape_interval: 5s\n\nscrape_configs:\n  - job_name: \"fastapi\"\n    static_configs:\n      - targets: [\"host.docker.internal:8000\"]\n</code></pre>"},{"location":"tools/grafana/setup/#dockerfile","title":"Dockerfile","text":"<p>Solution: Create a <code>Dockerfile</code> for FastAPI</p> <p>In your project root (same directory as <code>docker-compose.yml</code>), create a file named exactly <code>Dockerfile</code> (no extension) with the following contents:</p> <pre><code># Dockerfile for FastAPI app\n\nFROM python:3.12-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1\nENV PYTHONUNBUFFERED=1\n\n# Set working directory\nWORKDIR /app\n\n# Install pipenv\nRUN pip install pipenv\n\n# Copy Pipfile and install dependencies\nCOPY Pipfile Pipfile.lock ./\nRUN pipenv install --system --deploy --ignore-pipfile\n\n# Copy the application code\nCOPY . .\n\n# Expose FastAPI port\nEXPOSE 8000\n\n# Start the FastAPI app\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre> <p>\u2705 Then Try Again</p> <p>Once the <code>Dockerfile</code> is in place, run:</p> <pre><code>sudo docker-compose up --build\n</code></pre> <p>Optional: <code>.dockerignore</code></p> <p>Create a <code>.dockerignore</code> file to avoid copying unnecessary files into the contain</p> <pre><code>__pycache__/\n*.pyc\n*.pyo\n*.pyd\n.env\n.git\n</code></pre>"},{"location":"tools/grafana/setup/#build-and-run-all-services","title":"Build and Run All Services","text":"<pre><code>docker-compose up\n\n# or\n\nsudo docker-compose up\n</code></pre>"},{"location":"tools/grafana/setup/#access-grafana","title":"Access Grafana","text":"<ul> <li> <p>Grafana UI: http://localhost:3000</p> </li> <li> <p>Default login: <code>admin / admin</code></p> </li> </ul> <p>Add Prometheus as a data source:</p> <ul> <li>URL: <code>http://prometheus:9090</code></li> </ul> <p>Then create a dashboard using the metric <code>request_count</code>.</p> Check Docker Socket <p>See if the Docker socket exists:</p> <pre><code>ls -l /var/run/docker.sock\n</code></pre> <p>You should see something like:</p> <pre><code>srw-rw---- 1 root docker 0 Aug 2 12:34 /var/run/docker.sock\n</code></pre> <p>If you\u2019re not in the <code>docker</code> group, add yourself:</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>Then log out and back in, or run:</p> <pre><code>newgrp docker\n</code></pre> Try Using Docker with <code>sudo</code> <p>If nothing else works:</p> <pre><code>sudo docker-compose up\n</code></pre> <p>If this works, it's definitely a permissions issue.</p>"},{"location":"tools/observability-stack/overview/","title":"Overview","text":""},{"location":"tools/observability-stack/overview/#overview","title":"Overview","text":""},{"location":"tools/observability-stack/overview/#overview_1","title":"Overview","text":"<p>observability is a foundational concept in modern software development and DevOps.</p>"},{"location":"tools/observability-stack/overview/#what-is-an-observability-stack","title":"What Is an Observability Stack?","text":"<p>An observability stack is a set of tools and practices that allow you to understand what's happening inside your application or system, especially when things go wrong.</p> <p>It helps you answer:</p> <ul> <li>\u201cWhy is my app slow?\u201d</li> <li>\u201cWhy did this service fail?\u201d</li> <li>\u201cWhat caused this spike in traffic?\u201d</li> </ul>"},{"location":"tools/observability-stack/overview/#core-pillars-of-observability","title":"\ud83d\udcca Core Pillars of Observability","text":"<p>There are three key types of data in an observability stack, often called the 3 Pillars:</p> Pillar Description Example Tools Metrics Numeric time-series data about your system (e.g., CPU usage, requests/sec) Prometheus, InfluxDB Logs Textual records of events (e.g., error messages, request logs) Loki, ELK (Elasticsearch, Logstash, Kibana), Fluentd Traces End-to-end request flows through a system (e.g., what microservices were called and how long they took) Jaeger, Zipkin, OpenTelemetry"},{"location":"tools/observability-stack/overview/#typical-observability-stack","title":"\ud83e\uddf1 Typical Observability Stack","text":"<p>Here\u2019s a commonly used open-source observability stack:</p> Layer Tool Role Metrics Prometheus Collects &amp; stores metrics Visualization Grafana Dashboards &amp; alerts using Prometheus Logs Loki Stores and queries logs Tracing Jaeger or Tempo Tracks request paths across services Instrumentation OpenTelemetry Common API for collecting data"},{"location":"tools/observability-stack/overview/#why-is-it-useful","title":"\ud83e\udde0 Why Is It Useful?","text":"<ul> <li>Detect outages or slowdowns early</li> <li>Pinpoint bottlenecks and errors</li> <li>Provide alerts to engineers</li> <li>Improve incident response time</li> <li>Help with root cause analysis</li> </ul>"},{"location":"tools/observability-stack/overview/#fastapi-observability-stack-example","title":"\ud83d\ude80 FastAPI + Observability Stack (Example)","text":"<p>For your case with FastAPI:</p> <ul> <li>Metrics: Use <code>prometheus_client</code> to expose <code>/metrics</code></li> <li>Prometheus: Scrapes that endpoint</li> <li>Grafana: Visualizes metrics</li> <li>(Optional) Add logs (with Loki) and tracing (with OpenTelemetry)</li> </ul>"},{"location":"tools/observability-stack/overview/#setting-up-observability-stack-for-fastapi","title":"Setting up Observability Stack for FastAPI","text":"<p>Here's a basic Observability Stack for a FastAPI app using:</p> <ul> <li>\ud83d\udfe1 FastAPI</li> <li>\ud83d\udd35 Prometheus (metrics collector)</li> <li>\ud83d\udfe2 Grafana (dashboard/visualizer)</li> </ul> <p>Later, you can extend it with logging (e.g. <code>Loki</code>) and tracing (e.g. <code>Jaeger</code>).</p>"},{"location":"tools/observability-stack/overview/#docker-compose-setup","title":"\ud83d\udc33 Docker Compose Setup","text":"<p>Here's a minimal <code>docker-compose.yml</code> for:</p> <ol> <li>Your FastAPI app</li> <li>Prometheus</li> <li>Grafana</li> </ol>"},{"location":"tools/observability-stack/overview/#folder-structure","title":"\ud83d\udcc1 Folder Structure","text":"<pre><code>my-observability-stack/\n\u2502\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 prometheus/\n\u2502   \u2514\u2500\u2500 prometheus.yml\n</code></pre>"},{"location":"tools/observability-stack/overview/#docker-composeyml","title":"\ud83d\udce6 <code>docker-compose.yml</code>","text":"<pre><code>version: \"3.8\"\n\nservices:\n  fastapi:\n    build: ./app\n    ports:\n      - \"8000:8000\"\n    networks:\n      - monitor-net\n\n  prometheus:\n    image: prom/prometheus\n    volumes:\n      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml\n    ports:\n      - \"9090:9090\"\n    networks:\n      - monitor-net\n\n  grafana:\n    image: grafana/grafana\n    ports:\n      - \"3000:3000\"\n    networks:\n      - monitor-net\n\nnetworks:\n  monitor-net:\n</code></pre>"},{"location":"tools/observability-stack/overview/#prometheusprometheusyml","title":"\ud83d\udd27 <code>prometheus/prometheus.yml</code>","text":"<pre><code>global:\n  scrape_interval: 5s\n\nscrape_configs:\n  - job_name: \"fastapi\"\n    static_configs:\n      - targets: [\"fastapi:8000\"]\n</code></pre>"},{"location":"tools/observability-stack/overview/#appmainpy","title":"\ud83d\udc0d <code>app/main.py</code>","text":"<pre><code>from fastapi import FastAPI, Request\nfrom prometheus_client import start_http_server, Counter, generate_latest\nfrom prometheus_client import CONTENT_TYPE_LATEST\nfrom starlette.responses import Response\nimport uvicorn\n\nREQUEST_COUNTER = Counter(\"http_requests_total\", \"Total HTTP Requests\")\n\napp = FastAPI()\n\n@app.middleware(\"http\")\nasync def add_metrics_middleware(request: Request, call_next):\n    REQUEST_COUNTER.inc()\n    response = await call_next(request)\n    return response\n\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Hello from FastAPI!\"}\n\n@app.get(\"/metrics\")\ndef metrics():\n    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)\n</code></pre>"},{"location":"tools/observability-stack/overview/#apprequirementstxt","title":"\ud83d\udce6 <code>app/requirements.txt</code>","text":"<pre><code>fastapi\nuvicorn\nprometheus_client\n</code></pre>"},{"location":"tools/observability-stack/overview/#build-and-run","title":"\ud83c\udfc3\u200d\u2642\ufe0f Build and Run","text":"<p>From the project root:</p> <pre><code>docker-compose up --build\n\n#or\n\nsudo docker-compose up --build\n</code></pre>"},{"location":"tools/observability-stack/overview/#access-urls","title":"\ud83d\udd17 Access URLs","text":"Tool URL FastAPI http://localhost:8000 Metrics http://localhost:8000/metrics Prometheus http://localhost:9090 Grafana http://localhost:3000 <p>Grafana login: <code>admin / admin</code> (change after login)</p>"},{"location":"tools/observability-stack/overview/#in-grafana","title":"\ud83d\udcc8 In Grafana","text":"<ol> <li> <p>Go to <code>http://localhost:3000</code></p> </li> <li> <p>Add data source:</p> <ul> <li>Type: Prometheus</li> <li>URL: <code>http://prometheus:9090</code></li> </ul> </li> <li> <p>Create a dashboard with a panel.</p> <ul> <li>Use query: <code>http_requests_total</code></li> </ul> </li> </ol>"},{"location":"tools/observability-stack/overview/#next-steps","title":"\u2705 Next Steps","text":"<p>Once you get this working:</p> <ul> <li>Add Loki for logging</li> <li>Add Tempo or Jaeger for tracing</li> <li>Use OpenTelemetry for standardized instrumentation</li> </ul> <p>Would you like me to add logging (Loki) or tracing (Jaeger) next?</p>"},{"location":"tools/observability-stack/overview/#text-based-flowchart-style-diagram-visulization","title":"text-based, flowchart-style diagram VISULIZATION","text":"<p>Docker Compose Observability Stack with:</p> <ul> <li>FastAPI App</li> <li>Prometheus</li> <li>Grafana</li> </ul> <pre><code>+----------------------------+\n|     FastAPI Application    |\n|  - Runs on port 8000       |\n|  - Exposes /metrics        |\n+----------------------------+\n              |\n              V\n+----------------------------+\n|        Prometheus          |\n|  - Scrapes /metrics        |\n|  - Stores time-series data |\n|  - Uses prometheus.yml     |\n+----------------------------+\n              |\n              V\n+----------------------------+\n|          Grafana           |\n|  - Connects to Prometheus  |\n|  - Visualizes metrics      |\n|  - Dashboards &amp; Alerts     |\n+----------------------------+\n              |\n              V\n+----------------------------+\n|          You (User)        |\n|  - View metrics in browser |\n|  - Analyze, debug, monitor |\n+----------------------------+\n</code></pre> <p>\ud83d\udd04 Docker Compose Networking</p> <p>All services are on the same Docker network, so they can reach each other by container name:</p> <ul> <li>Prometheus can scrape FastAPI via <code>http://fastapi:8000/metrics</code></li> <li>Grafana connects to Prometheus via <code>http://prometheus:9090</code></li> </ul> <p>\ud83d\udce6 Updated Docker Compose Diagram (Text-Based)</p> <pre><code>+----------------------------+\n|     FastAPI Application    |\n|  - Exposes:                |\n|     \u2022 /metrics (Prometheus)|\n|     \u2022 Logs (Loki)          |\n|     \u2022 Traces (Jaeger)      |\n+----------------------------+\n       |       |       |\n       |       |       |\n       V       V       V\n+-----------+ +----------+ +----------+\n| Prometheus| |   Loki   | |  Jaeger  |\n|  Metrics  | |   Logs   | | Traces   |\n+-----------+ +----------+ +----------+\n       \\        |        /\n        \\       |       /\n         V      V      V\n         +------------------------+\n         |        Grafana         |\n         | - Dashboards (All Data)|\n         +------------------------+\n                     |\n                     V\n            +------------------+\n            |   You (Developer)|\n            +------------------+\n</code></pre> <p>\ud83d\udc33 Next Step: Add Loki and Jaeger to <code>docker-compose.yml</code></p> <p>Would you like me to:</p> <ol> <li>\ud83d\udd27 Give you the full updated <code>docker-compose.yml</code> with Loki &amp; Jaeger?</li> <li>\ud83d\udcc2 Provide file structure + config files (e.g. for Loki and Promtail)?</li> <li>\u2705 Or just a minimal Loki &amp; Jaeger config added to your existing stack?</li> </ol> <p>Let me know your preference, and I\u2019ll tailor it for you.</p>"},{"location":"tools/observability-stack/stack-architecture/","title":"Stack Architecture","text":""},{"location":"tools/observability-stack/stack-architecture/#observability-stack-architecture","title":"\ud83e\uddf1 Observability Stack Architecture","text":"<p>This document outlines the architecture of a modern observability stack using:</p> <ul> <li>Prometheus for metrics</li> <li>Loki for logs</li> <li>Tempo for traces</li> <li>Grafana as the unified dashboard</li> </ul> <p>This stack provides full visibility into your application's health, behavior, and performance.</p>"},{"location":"tools/observability-stack/stack-architecture/#overview","title":"\ud83e\udded Overview","text":"<p>\ud83d\udd0d Observability answers:</p> <ul> <li>What is happening? (Metrics)</li> <li>Why is it happening? (Logs)</li> <li>Where did it happen? (Traces)</li> </ul>"},{"location":"tools/observability-stack/stack-architecture/#core-components","title":"\ud83e\uddca Core Components","text":"Component Purpose Visualization Prometheus Scrapes metrics from applications Grafana Loki Collects and indexes logs Grafana Tempo Collects distributed traces Grafana Grafana Visualizes all of the above Web UI"},{"location":"tools/observability-stack/stack-architecture/#architecture-diagram","title":"\ud83e\uddec Architecture Diagram","text":"<pre><code>                        +--------------------------+\n                        |      Grafana Dashboards  |\n                        |   (Metrics / Logs / Traces) |\n                        +-----------+--------------+\n                                    |\n      +-----------------------------+-----------------------------+\n      |                             |                             |\n+-------------+           +------------------+         +------------------+\n| Prometheus  | &lt;---scrapes--- |   FastAPI App   | --traces--&gt; |     Tempo         |\n| (metrics)   |               | (via /metrics)  |             | (tracing backend) |\n+-------------+               +------------------+             +------------------+\n                                    |\n                             logs via stdout\n                                    |\n                             +--------------+\n                             |     Promtail |\n                             | (or Grafana Agent) |\n                             +--------------+\n                                    |\n                               +--------+\n                               |  Loki  |\n                               +--------+\n</code></pre>"},{"location":"tools/observability-stack/stack-architecture/#data-flow-summary","title":"\u2699\ufe0f Data Flow Summary","text":"<ol> <li> <p>Metrics (Prometheus):</p> <ul> <li>Your FastAPI app exposes metrics via <code>/metrics</code> (e.g., with <code>prometheus_client</code>)</li> <li>Prometheus scrapes them periodically</li> <li>Grafana queries and visualizes them</li> </ul> </li> <li> <p>Logs (Loki):</p> <ul> <li>Application logs (e.g., <code>loguru</code>, <code>structlog</code>, <code>uvicorn</code>) go to <code>stdout</code></li> <li>Promtail or Grafana Agent tails logs and sends them to Loki</li> <li>Logs are labeled (e.g., by service, pod, env) and searchable in Grafana</li> </ul> </li> <li> <p>Traces (Tempo):</p> <ul> <li>FastAPI app is instrumented using OpenTelemetry</li> <li>Requests generate traces (including spans for DB, HTTP, etc.)</li> <li>Traces are exported via OTLP to Tempo</li> <li>Tempo stores and indexes traces for viewing in Grafana</li> </ul> </li> </ol>"},{"location":"tools/observability-stack/stack-architecture/#component-integration","title":"\ud83e\udde9 Component Integration","text":"Tool Input Source Output / Integration Prometheus <code>/metrics</code> endpoint Grafana dashboards, Alerts Loki Logs from stdout/stderr Grafana Explore Tempo OpenTelemetry SDK Grafana trace viewer Grafana Prometheus, Loki, Tempo Unified view"},{"location":"tools/observability-stack/stack-architecture/#benefits-of-this-stack","title":"\u2705 Benefits of This Stack","text":"<ul> <li>Single pane of glass: All telemetry in one UI</li> <li>Correlated insights: Link logs \u2194 traces \u2194 metrics</li> <li>Open source and cloud-native</li> <li>Minimal vendor lock-in (fully OSS or self-hostable)</li> </ul>"},{"location":"tools/observability-stack/stack-architecture/#example-use-case","title":"\ud83d\udee0\ufe0f Example Use Case","text":"<p>Issue: Latency spike on <code>/api/orders</code></p> <p>With this stack you can:</p> <ol> <li>Use Prometheus to see when latency increased</li> <li>Click a spike in Grafana \u2192 view Tempo trace</li> <li>Trace shows DB query took 1.2s</li> <li>Jump to Loki logs for same <code>trace_id</code></li> <li>See error log: <code>\u201cIndex on orders.created_at missing\u201d</code></li> </ol> <p>\u2705 You identified what, where, and why \u2014 across tools in seconds.</p>"},{"location":"tools/observability-stack/stack-architecture/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Metrics with Prometheus</li> <li>Logging with Loki</li> <li>Tracing with Tempo and FastAPI</li> </ul>"},{"location":"tools/observability-stack/topics/","title":"Topic","text":""},{"location":"tools/observability-stack/topics/#topic","title":"Topic","text":"<p>That's great\u2014you\u2019ve already touched on some important observability tools like Prometheus and Grafana, and you're using FastAPI, a modern and high-performance Python web framework. That\u2019s a solid start!</p>"},{"location":"tools/observability-stack/topics/#overview","title":"Overview","text":"<p>To master advanced backend programming, here\u2019s a structured list of advanced backend topics, categorized for clarity:</p>"},{"location":"tools/observability-stack/topics/#1-system-design-architecture","title":"\ud83d\udd27 1. System Design &amp; Architecture","text":"<p>Understanding how to architect systems is crucial.</p> <ul> <li>Microservices Architecture</li> <li>Monolith vs Microservices vs Serverless</li> <li>API Gateway (e.g., Kong, NGINX, Envoy)</li> <li>Service Mesh (e.g., Istio, Linkerd)</li> <li>Domain-Driven Design (DDD)</li> <li>Event-Driven Architecture (with Kafka or RabbitMQ)</li> <li>Clean Architecture &amp; Hexagonal Architecture</li> <li>Load balancing, failover strategies</li> </ul>"},{"location":"tools/observability-stack/topics/#2-performance-scalability","title":"\u2699\ufe0f 2. Performance &amp; Scalability","text":"<ul> <li>Horizontal vs Vertical Scaling</li> <li>Caching: Redis, Memcached, CDN usage</li> <li>Asynchronous Programming: <code>asyncio</code>, <code>celery</code>, <code>kombu</code></li> <li>Rate Limiting / Throttling</li> <li>Backpressure handling</li> </ul>"},{"location":"tools/observability-stack/topics/#3-security","title":"\ud83d\udd10 3. Security","text":"<ul> <li>OAuth2, JWT, OpenID Connect</li> <li>TLS/SSL, HTTPS, CSRF, XSS, CORS</li> <li>API Security Best Practices</li> <li>Authentication &amp; Authorization Layers</li> <li>Secrets Management (Vault, AWS Secrets Manager)</li> </ul>"},{"location":"tools/observability-stack/topics/#4-devops-observability","title":"\ud83d\udce6 4. DevOps &amp; Observability","text":"<p>You\u2019ve started with Prometheus + Grafana, which is great.</p> <p>Add:</p> <ul> <li>Logging: ELK Stack (Elasticsearch, Logstash, Kibana), Loki</li> <li>Tracing: OpenTelemetry, Jaeger</li> <li>Metrics: Custom metrics with Prometheus</li> <li>Alerting: Prometheus Alertmanager</li> <li>Docker &amp; Containerization</li> <li>CI/CD Pipelines: GitHub Actions, GitLab CI, Jenkins</li> </ul>"},{"location":"tools/observability-stack/topics/#5-databases-sql-nosql","title":"\ud83d\uddc3\ufe0f 5. Databases (SQL + NoSQL)","text":"<ul> <li>Advanced SQL Queries, Indexing, Query Planning</li> <li>PostgreSQL or MySQL Internals</li> <li>NoSQL (MongoDB, Cassandra, DynamoDB)</li> <li>Database Scaling: Sharding, Replication</li> <li>ORM Performance Optimization</li> <li>Migrations &amp; Schema Management</li> </ul>"},{"location":"tools/observability-stack/topics/#6-messaging-queue-systems","title":"\ud83d\udef0\ufe0f 6. Messaging &amp; Queue Systems","text":"<ul> <li>Kafka, RabbitMQ, Redis Streams</li> <li>Message patterns: Pub/Sub, Fanout, Dead Letter Queues</li> <li>Idempotency and retry handling</li> </ul>"},{"location":"tools/observability-stack/topics/#7-testing-quality-assurance","title":"\ud83e\uddea 7. Testing &amp; Quality Assurance","text":"<ul> <li>Unit, Integration, End-to-End Testing</li> <li>Load Testing (Locust, k6)</li> <li>Contract Testing (e.g., Pact)</li> <li>Test-Driven Development (TDD)</li> </ul>"},{"location":"tools/observability-stack/topics/#8-cloud-infrastructure","title":"\u2601\ufe0f 8. Cloud &amp; Infrastructure","text":"<ul> <li>AWS / GCP / Azure Core Services</li> <li>IaC (Infrastructure as Code): Terraform, Pulumi</li> <li>Kubernetes Basics + Advanced Concepts</li> <li>Networking (VPC, subnets, NAT, firewall rules)</li> </ul>"},{"location":"tools/observability-stack/topics/#9-advanced-api-design","title":"\ud83d\udcf1 9. Advanced API Design","text":"<ul> <li>Versioning</li> <li>Pagination, Filtering, Sorting</li> <li>GraphQL APIs</li> <li>gRPC / Protobuf</li> <li>HATEOAS / REST maturity levels</li> </ul>"},{"location":"tools/observability-stack/topics/#10-real-world-scalability-practices","title":"\ud83d\udcc8 10. Real-World Scalability Practices","text":"<ul> <li>Circuit Breakers / Bulkheads (e.g., Resilience4j)</li> <li>Distributed Tracing</li> <li>Handling Failures Gracefully</li> <li>Chaos Engineering Basics (e.g., Gremlin)</li> </ul>"},{"location":"tools/observability-stack/topics/#suggestions-to-deepen-knowledge","title":"\ud83d\udcda Suggestions to Deepen Knowledge","text":"<ul> <li>Read \"Designing Data-Intensive Applications\" by Martin Kleppmann</li> <li>Explore \u201cThe Pragmatic Programmer\u201d</li> <li>Study case studies of companies like Netflix, Uber, etc.</li> </ul>"},{"location":"tools/observability-stack/topics/#roadmap","title":"Roadmap","text":"<p>Would you like me to organize a learning roadmap with these topics prioritized for you based on your current knowledge (e.g., with FastAPI and Prometheus)?</p> <p>Great! Since you're already using FastAPI and have worked with Prometheus + Grafana, I'll assume:</p> <ul> <li>You\u2019re comfortable with Python and basic web APIs.</li> <li>You understand HTTP, routing, and REST basics.</li> <li>You\u2019ve deployed or monitored a service at least in development/staging.</li> </ul> <p>Here\u2019s a personalized roadmap to mastering advanced backend development, broken into 4 levels:</p>"},{"location":"tools/observability-stack/topics/#phase-1-strengthen-the-core","title":"\ud83e\udde9 Phase 1: Strengthen the Core","text":"<p>Goal: Deepen your understanding of backend fundamentals and build robust, clean APIs.</p> <p>Topics:</p> <ul> <li> <p>\u2705 Advanced FastAPI</p> </li> <li> <p>Dependency injection</p> </li> <li>Background tasks</li> <li>WebSockets</li> <li>Middleware</li> <li> <p>FastAPI + Pydantic V2 performance tuning</p> </li> <li> <p>\u2705 SQL Mastery (PostgreSQL/MySQL)</p> </li> <li> <p>Joins, indexes, query planning</p> </li> <li>Transactions &amp; isolation levels</li> <li> <p>ORMs (SQLAlchemy Core vs ORM)</p> </li> <li> <p>\u2705 Caching</p> </li> <li> <p>Redis for in-memory caching</p> </li> <li> <p>Cache invalidation strategies</p> </li> <li> <p>\u2705 Authentication &amp; Authorization</p> </li> <li> <p>JWT, OAuth2 with FastAPI</p> </li> <li>Role-based access control (RBAC)</li> </ul>"},{"location":"tools/observability-stack/topics/#phase-2-build-production-grade-systems","title":"\ud83e\uddf1 Phase 2: Build Production-Grade Systems","text":"<p>Goal: Learn how to scale, monitor, and secure services in real-world environments.</p> <p>Topics:</p> <ul> <li> <p>\u2705 Observability</p> </li> <li> <p>Prometheus: custom metrics</p> </li> <li>Grafana dashboards</li> <li>Logging (Structlog, Loguru, or ELK)</li> <li> <p>Tracing with OpenTelemetry or Jaeger</p> </li> <li> <p>\u2705 Asynchronous Programming</p> </li> <li> <p>Python <code>asyncio</code>, FastAPI async routes</p> </li> <li> <p>Task queues: Celery, Redis Queue</p> </li> <li> <p>\u2705 Docker &amp; Docker Compose</p> </li> <li> <p>Build, run, network multiple services</p> </li> <li> <p>\u2705 Testing</p> </li> <li> <p>Pytest: unit, integration, and E2E</p> </li> <li>Test coverage, mocking, fixtures</li> </ul>"},{"location":"tools/observability-stack/topics/#phase-3-advanced-architecture-devops","title":"\ud83c\udf10 Phase 3: Advanced Architecture &amp; DevOps","text":"<p>Goal: Design scalable, resilient systems and manage deployments like a pro.</p> <p>Topics:</p> <ul> <li> <p>\u2705 System Design Basics</p> </li> <li> <p>Load balancers, reverse proxies</p> </li> <li> <p>Horizontal scaling, stateless services</p> </li> <li> <p>\u2705 API Gateway Concepts</p> </li> <li> <p>Kong, NGINX, or Traefik usage</p> </li> <li> <p>\u2705 CI/CD Pipelines</p> </li> <li> <p>GitHub Actions or GitLab CI</p> </li> <li> <p>Auto-deploy on push or merge</p> </li> <li> <p>\u2705 Infrastructure as Code</p> </li> <li> <p>Terraform (AWS/GCP basics)</p> </li> <li> <p>\u2705 Cloud</p> </li> <li> <p>AWS core services: EC2, RDS, S3, IAM</p> </li> <li>Deploying FastAPI with Gunicorn + NGINX</li> </ul>"},{"location":"tools/observability-stack/topics/#phase-4-high-level-architecture-real-world-practices","title":"\u26a1 Phase 4: High-Level Architecture &amp; Real-World Practices","text":"<p>Goal: Learn how large-scale systems work and how to design fault-tolerant, scalable APIs.</p> <p>Topics:</p> <ul> <li> <p>\u2705 Message Brokers</p> </li> <li> <p>Kafka or RabbitMQ</p> </li> <li> <p>Event-driven design (Pub/Sub)</p> </li> <li> <p>\u2705 Microservices Architecture</p> </li> <li> <p>Service discovery</p> </li> <li>Inter-service communication (REST, gRPC)</li> <li> <p>Database per service pattern</p> </li> <li> <p>\u2705 Advanced API Design</p> </li> <li> <p>Pagination, filtering, versioning</p> </li> <li>GraphQL vs REST trade-offs</li> <li> <p>gRPC with Python</p> </li> <li> <p>\u2705 Distributed Systems Concepts</p> </li> <li> <p>CAP theorem, consistency models</p> </li> <li>Circuit breakers, retries, timeouts</li> <li>Idempotency in distributed APIs</li> </ul>"},{"location":"tools/observability-stack/topics/#bonus-reading-projects","title":"\ud83e\udde0 Bonus Reading &amp; Projects","text":"<p>Books:</p> <ul> <li>Designing Data-Intensive Applications \u2013 Martin Kleppmann</li> <li>The Phoenix Project (DevOps focus)</li> <li>Clean Architecture \u2013 Uncle Bob</li> </ul> <p>Projects to Try:</p> <ul> <li>\ud83d\uded2 E-commerce microservice (cart, auth, orders)</li> <li>\ud83d\ude80 Real-time chat app (WebSocket + Redis)</li> <li>\ud83d\udcca Monitoring dashboard (Prometheus + custom metrics)</li> <li>\ud83c\udf0d API gateway proxy in front of multiple microservices</li> </ul>"},{"location":"tools/prometheus/overview/","title":"Overview","text":""},{"location":"tools/prometheus/setup/","title":"Setup","text":""},{"location":"tools/prometheus/setup/#setup","title":"Setup","text":"<p>To set up a FastAPI app with Prometheus for metrics and Grafana for visualization</p> <pre><code>pipenv install fastapi uvicorn prometheus-fastapi-instrumentator\n\n# or\n\npipenv install fastapi uvicorn prometheus_client\n</code></pre> <p>For development (auto-reload, etc.):</p> <pre><code>pipenv install --dev python-dotenv\n</code></pre> <p>The difference between prometheus_client and prometheus-fastapi-instrumentator lies in abstraction level, ease of use, and target use-case:</p>"},{"location":"tools/prometheus/setup/#prometheus_client","title":"\ud83d\udd27 <code>prometheus_client</code>","text":"<p>What it is:</p> <ul> <li>The official low-level Python client for Prometheus.</li> <li>Lets you define and manage metrics manually (counters, histograms, gauges, etc.).</li> <li>Framework-agnostic (can be used with FastAPI, Flask, Django, etc.).</li> </ul> <p>Use it when:</p> <ul> <li>You want fine-grained control over metrics.</li> <li>You're building custom instrumentation.</li> <li>You're not using FastAPI or need something portable.</li> <li>You are okay with writing more boilerplate (e.g., creating endpoints, tracking latencies manually).</li> </ul> <p>Pros:</p> <ul> <li>Full control.</li> <li>Official and well-maintained.</li> <li>No external abstraction.</li> </ul> <p>Cons:</p> <ul> <li>More boilerplate.</li> <li>Not plug-and-play with FastAPI.</li> </ul>"},{"location":"tools/prometheus/setup/#prometheus-fastapi-instrumentator","title":"\ud83d\ude80 <code>prometheus-fastapi-instrumentator</code>","text":"<p>What it is:</p> <ul> <li>A high-level wrapper around <code>prometheus_client</code> for FastAPI applications.</li> <li>Automatically instruments common metrics like HTTP request durations, status codes, path info, etc.</li> <li>Adds a ready-made <code>/metrics</code> endpoint.</li> <li>Allows customization, but handles most Prometheus boilerplate for you.</li> </ul> <p>Use it when:</p> <ul> <li>You're using FastAPI.</li> <li>You want easy and fast instrumentation.</li> <li>You're okay with some abstraction.</li> <li>You want to avoid manual metric wiring for HTTP metrics.</li> </ul> <p>Pros:</p> <ul> <li>Plug-and-play.</li> <li>Auto-instruments your app.</li> <li>Saves time for typical web metrics.</li> </ul> <p>Cons:</p> <ul> <li>Slightly less control than <code>prometheus_client</code>.</li> <li>Adds an extra dependency.</li> <li>Not suited for non-FastAPI apps.</li> </ul>"},{"location":"tools/prometheus/setup/#which-one-should-you-use","title":"\u2705 Which One Should You Use?","text":"Use Case Recommendation You're using FastAPI and want easy metrics (request count, latency, etc.) \u2705 Use <code>prometheus-fastapi-instrumentator</code> You're building a custom metrics system or working outside FastAPI \u2705 Use <code>prometheus_client</code> You need both: automatic HTTP metrics and some custom metrics Use both together (the instrumentator internally uses <code>prometheus_client</code>)"},{"location":"tools/prometheus/setup/#example","title":"Example:","text":"<p><code>prometheus-fastapi-instrumentator</code>:</p> <pre><code>from fastapi import FastAPI\nfrom prometheus_fastapi_instrumentator import Instrumentator\n\napp = FastAPI()\nInstrumentator().instrument(app).expose(app)\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n</code></pre> <p><code>prometheus_client</code> (manual):</p> <pre><code>from fastapi import FastAPI, Request\nfrom prometheus_client import Counter, generate_latest\nfrom starlette.responses import Response\n\napp = FastAPI()\nREQUEST_COUNT = Counter(\"request_count\", \"Total number of requests\")\n\n@app.middleware(\"http\")\nasync def count_requests(request: Request, call_next):\n    REQUEST_COUNT.inc()\n    return await call_next(request)\n\n@app.get(\"/metrics\")\ndef metrics():\n    return Response(generate_latest(), media_type=\"text/plain\")\n</code></pre> <p>If you're prototyping, building APIs quickly, or don\u2019t need full control: start with <code>prometheus-fastapi-instrumentator</code>. You can always drop down to <code>prometheus_client</code> if needed.</p>"},{"location":"websockets/authentication/","title":"Authentication","text":""},{"location":"websockets/authentication/#websocket-authentication","title":"WebSocket Authentication","text":"<p>Unlike traditional HTTP requests, WebSocket connections do not automatically include headers like cookies or authorization tokens with each message. Therefore, authentication must be explicitly handled during the initial handshake or in the first message after connection.</p> <p>This guide covers common WebSocket authentication patterns and best practices.</p>"},{"location":"websockets/authentication/#why-authenticate-websocket-connections","title":"\ud83d\udd10 Why Authenticate WebSocket Connections?","text":"<p>Authentication ensures that:</p> <ul> <li>Only authorized users can establish a connection.</li> <li>Access to rooms, channels, or event streams can be restricted.</li> <li>Sensitive actions are protected from unauthorized execution.</li> <li>Session data can be tied to the user identity.</li> </ul>"},{"location":"websockets/authentication/#recommended-patterns","title":"\u2705 Recommended Patterns","text":""},{"location":"websockets/authentication/#1-token-in-query-parameters-handshake-level","title":"1. Token in Query Parameters (Handshake Level)","text":"<p>Append a token (e.g., JWT or session token) in the WebSocket URL:</p> <pre><code>const socket = new WebSocket(\n  \"wss://api.example.com/ws?token=eyJhbGciOiJIUz...\"\n);\n</code></pre> <p>Server-Side (Python/FastAPI Example):</p> <pre><code>from fastapi import WebSocket, WebSocketDisconnect\nfrom jose import JWTError, jwt\n\nSECRET_KEY = \"your_secret\"\n\nasync def get_user_from_token(token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload.get(\"sub\")\n    except JWTError:\n        return None\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    token = websocket.query_params.get(\"token\")\n    user = await get_user_from_token(token)\n\n    if user is None:\n        await websocket.close(code=1008)\n        return\n\n    await websocket.accept()\n    # Proceed with authenticated user\n</code></pre> <p>Pros:</p> <ul> <li>Simple and works with any client.</li> <li>Token can expire or be revoked server-side.</li> </ul> <p>Cons:</p> <ul> <li>Token is exposed in browser history and server logs unless using HTTPS.</li> </ul>"},{"location":"websockets/authentication/#2-token-in-first-message-post-connect-auth","title":"2. Token in First Message (Post-Connect Auth)","text":"<p>Send the token as part of the first client message:</p> <pre><code>socket.onopen = () =&gt; {\n  socket.send(\n    JSON.stringify({\n      type: \"auth\",\n      token: \"eyJhbGciOiJIUz...\",\n    })\n  );\n};\n</code></pre> <p>Server-Side Pattern:</p> <pre><code>async def receive_auth_message(websocket: WebSocket):\n    data = await websocket.receive_json()\n    if data.get(\"type\") != \"auth\":\n        await websocket.close(code=1008)\n        return None\n    return await get_user_from_token(data.get(\"token\"))\n</code></pre> <p>Pros:</p> <ul> <li>More secure than exposing the token in the URL.</li> <li>Works well for complex flows (e.g., re-auth, session refresh).</li> </ul> <p>Cons:</p> <ul> <li>Requires server to track state before authentication is complete.</li> <li>Some frameworks don\u2019t support reading messages before <code>accept()</code>.</li> </ul>"},{"location":"websockets/authentication/#3-custom-headers-limited-support","title":"3. Custom Headers (Limited Support)","text":"<p>Most browsers do not support sending custom headers in WebSocket connections due to security restrictions. However, some native clients (e.g., mobile apps or Python scripts) can send headers like:</p> <pre><code>import websockets\n\nheaders = {\n    \"Authorization\": \"Bearer eyJhbGciOiJIUz...\"\n}\nasync with websockets.connect(\"wss://example.com/ws\", extra_headers=headers):\n    ...\n</code></pre> <p>Use this only for non-browser clients.</p>"},{"location":"websockets/authentication/#handling-reconnection-and-expired-tokens","title":"\ud83d\udd04 Handling Reconnection and Expired Tokens","text":"<p>Ensure your backend:</p> <ul> <li>Rejects expired or invalid tokens with code <code>1008</code> (Policy Violation).</li> <li>Allows clients to re-authenticate by sending a new token if needed.</li> <li>Uses short-lived tokens and refresh tokens securely.</li> </ul>"},{"location":"websockets/authentication/#websocket-close-codes-for-auth-failures","title":"\ud83d\udcdb WebSocket Close Codes for Auth Failures","text":"<p>Use meaningful close codes when rejecting clients:</p> Code Name Meaning <code>1008</code> Policy Violation Invalid/missing token <code>4001</code> Custom Code Token expired <code>4003</code> Custom Code Unauthorized access <p>Clients should handle these and trigger appropriate UI responses or retry logic.</p>"},{"location":"websockets/authentication/#example-client-implementation-javascript","title":"\ud83d\udd0d Example Client Implementation (JavaScript)","text":"<pre><code>const token = getAuthToken(); // e.g., from localStorage\n\nconst socket = new WebSocket(`wss://api.example.com/ws?token=${token}`);\n\nsocket.onmessage = (event) =&gt; {\n  const data = JSON.parse(event.data);\n  // Handle events\n};\n\nsocket.onclose = (event) =&gt; {\n  if (event.code === 1008) {\n    alert(\"Authentication failed. Please log in again.\");\n  }\n};\n</code></pre>"},{"location":"websockets/authentication/#best-practices","title":"\u2705 Best Practices","text":"<ul> <li>Always use HTTPS/WSS to prevent token sniffing.</li> <li>Use JWTs for stateless authentication.</li> <li>Expire tokens and handle renewal.</li> <li>Close unauthorized connections early.</li> <li>Log authentication failures for auditing.</li> </ul>"},{"location":"websockets/authentication/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Message Format: Structure your messages for security and clarity.</li> <li>Clients: Implement client-side reconnection and authentication.</li> <li>FastAPI Integration: Add full support to your backend framework.</li> </ul>"},{"location":"websockets/error-handling/","title":"Error Handling","text":""},{"location":"websockets/error-handling/#websocket-error-handling","title":"WebSocket Error Handling","text":"<p>Error handling in WebSocket applications is essential for building a robust, predictable real-time experience. Since WebSockets are persistent and event-driven, your system must clearly communicate both protocol-level and application-level errors.</p> <p>This page covers error categories, message formats, best practices, and how to gracefully handle failures.</p>"},{"location":"websockets/error-handling/#1-types-of-errors","title":"\u2757 1. Types of Errors","text":"Type Description Examples Connection-level Issues during connection or handshake Invalid auth token, unsupported path Application-level Errors in event logic or payload processing Invalid room ID, permission denied Transport-level Network failures, client disconnects, timeouts Lost connection, ping timeout"},{"location":"websockets/error-handling/#2-error-message-format","title":"\ud83e\uddf1 2. Error Message Format","text":"<p>Your application should return errors in a consistent JSON structure:</p> <pre><code>{\n  \"type\": \"error\",\n  \"data\": {\n    \"code\": 4001,\n    \"message\": \"Room not found\"\n  },\n  \"meta\": {\n    \"request_id\": \"abc-123\",\n    \"timestamp\": \"2025-08-04T12:00:00Z\"\n  }\n}\n</code></pre> <p>Field Definitions</p> Field Description <code>type</code> Always <code>\"error\"</code> <code>data.code</code> Numeric error code <code>data.message</code> Human-readable error message <code>meta</code> Optional context (timestamp, request ID)"},{"location":"websockets/error-handling/#3-custom-error-codes","title":"\ud83d\udd22 3. Custom Error Codes","text":"Code Meaning Use Case <code>4000</code> Bad request Malformed JSON or missing fields <code>4001</code> Not found Room, user, or resource not found <code>4002</code> Invalid action Sending message to closed room <code>4003</code> Unauthorized Token missing or expired <code>4004</code> Forbidden User lacks permission <code>4005</code> Rate limited Too many requests <code>5000</code> Internal server error Unexpected backend failure"},{"location":"websockets/error-handling/#4-closing-with-errors","title":"\ud83d\udea8 4. Closing with Errors","text":"<p>If a critical error requires closing the connection, send an <code>error</code> message first, then close:</p> <p>Server:</p> <pre><code>{\n  \"type\": \"error\",\n  \"data\": {\n    \"code\": 4003,\n    \"message\": \"Authentication failed\"\n  }\n}\n</code></pre> <p>Then:</p> <pre><code>await websocket.close(code=4003)\n</code></pre> <p>Clients should listen for both <code>message</code> and <code>close</code> events.</p>"},{"location":"websockets/error-handling/#5-client-handling-example-javascript","title":"\ud83d\udee0 5. Client Handling Example (JavaScript)","text":"<pre><code>socket.onmessage = (event) =&gt; {\n  const msg = JSON.parse(event.data);\n\n  if (msg.type === \"error\") {\n    console.error(`[WebSocket Error] ${msg.data.code}: ${msg.data.message}`);\n    alert(\"Something went wrong: \" + msg.data.message);\n  }\n};\n\nsocket.onclose = (event) =&gt; {\n  if (event.code === 4003) {\n    alert(\"You were disconnected due to authentication failure.\");\n  }\n};\n</code></pre>"},{"location":"websockets/error-handling/#6-best-practices","title":"\u2705 6. Best Practices","text":"<ul> <li>Use structured error responses with consistent codes.</li> <li>Never expose stack traces or internals in messages.</li> <li>Log all server-side errors with context and traceback.</li> <li>Differentiate between recoverable and fatal errors.</li> <li>Allow clients to retry or reconnect after soft failures.</li> </ul>"},{"location":"websockets/error-handling/#7-testing-your-error-handling","title":"\ud83e\uddea 7. Testing Your Error Handling","text":"<ul> <li>Simulate invalid messages (e.g., bad JSON, unknown <code>type</code>).</li> <li>Force auth failures (e.g., expired tokens).</li> <li>Disconnect network mid-session.</li> <li>Exceed rate limits to test throttling responses.</li> <li>Monitor logs for uncaught exceptions.</li> </ul>"},{"location":"websockets/error-handling/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Connection Events: Handle connection-related failures.</li> <li>Authentication: Prevent errors before accepting a socket.</li> <li>Clients: Build fault-tolerant frontends.</li> </ul>"},{"location":"websockets/message-format/","title":"Message Format","text":""},{"location":"websockets/message-format/#websocket-message-format","title":"WebSocket Message Format","text":"<p>In a WebSocket-based system, messages are often exchanged in a structured format such as JSON. Designing a clean and consistent message format is essential for ensuring reliable, secure, and extensible communication between the client and server.</p> <p>This page outlines the standard structure we use for messages, how to handle types, payloads, errors, and versioning.</p>"},{"location":"websockets/message-format/#message-envelope","title":"\ud83e\uddf1 Message Envelope","text":"<p>Each message follows a consistent JSON structure:</p> <pre><code>{\n  \"type\": \"event_name\",\n  \"data\": { ... },\n  \"meta\": {\n    \"request_id\": \"uuid-123\",\n    \"timestamp\": \"2025-08-04T12:34:56Z\"\n  }\n}\n</code></pre>"},{"location":"websockets/message-format/#field-definitions","title":"Field Definitions","text":"Field Type Required Description <code>type</code> <code>string</code> \u2705 The event type or message name <code>data</code> <code>object</code> \u2705 The payload relevant to the event <code>meta</code> <code>object</code> \u274c Optional metadata (e.g., timestamp, request ID)"},{"location":"websockets/message-format/#example-messages","title":"\ud83c\udfaf Example Messages","text":""},{"location":"websockets/message-format/#join-a-room","title":"\u2705 Join a Room","text":"<p>Client \u2192 Server:</p> <pre><code>{\n  \"type\": \"join_room\",\n  \"data\": {\n    \"room_id\": \"room-abc\"\n  }\n}\n</code></pre> <p>Server \u2192 Client (Success):</p> <pre><code>{\n  \"type\": \"room_joined\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"users\": [\"user1\", \"user2\"]\n  }\n}\n</code></pre>"},{"location":"websockets/message-format/#send-a-chat-message","title":"\ud83d\udcdd Send a Chat Message","text":"<p>Client \u2192 Server:</p> <pre><code>{\n  \"type\": \"send_message\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"message\": \"Hello world!\"\n  }\n}\n</code></pre> <p>Server \u2192 All Clients:</p> <pre><code>{\n  \"type\": \"new_message\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"user\": \"user1\",\n    \"message\": \"Hello world!\",\n    \"timestamp\": \"2025-08-04T12:35:10Z\"\n  }\n}\n</code></pre>"},{"location":"websockets/message-format/#error-messages","title":"\u26a0\ufe0f Error Messages","text":"<p>Standard format for error responses:</p> <pre><code>{\n  \"type\": \"error\",\n  \"data\": {\n    \"code\": 4001,\n    \"message\": \"Room not found\"\n  }\n}\n</code></pre> Field Description <code>code</code> Numeric code for programmatic use <code>message</code> Human-readable explanation"},{"location":"websockets/message-format/#server-to-client-event-types","title":"\ud83d\udee1\ufe0f Server-to-Client Event Types","text":"Event Type Description <code>room_joined</code> Confirmation of room join <code>new_message</code> Broadcast of a new message <code>user_typing</code> Optional \"user is typing\" indicator <code>error</code> Error response <code>ping</code> / <code>pong</code> Heartbeat mechanism <code>disconnect</code> Server intent to close the connection"},{"location":"websockets/message-format/#message-flow-example","title":"\ud83d\udd01 Message Flow Example","text":"<pre><code>Client:    {\"type\": \"join_room\", \"data\": {\"room_id\": \"abc\"}}\nServer:    {\"type\": \"room_joined\", \"data\": {\"room_id\": \"abc\", \"users\": [...]}}\nClient:    {\"type\": \"send_message\", \"data\": {\"room_id\": \"abc\", \"message\": \"Hi\"}}\nServer:    {\"type\": \"new_message\", \"data\": {\"room_id\": \"abc\", \"user\": \"...\", \"message\": \"Hi\"}}\n</code></pre>"},{"location":"websockets/message-format/#versioning-optional","title":"\ud83d\udce6 Versioning (Optional)","text":"<p>If you expect future changes:</p> <pre><code>{\n  \"type\": \"send_message\",\n  \"version\": \"1.0\",\n  \"data\": {\n    ...\n  }\n}\n</code></pre> <p>Use the <code>version</code> field to gracefully handle schema evolution over time.</p>"},{"location":"websockets/message-format/#best-practices","title":"\u2705 Best Practices","text":"<ul> <li>Always include a <code>type</code> field to define intent.</li> <li>Keep payloads minimal and validate on both ends.</li> <li>Use UUIDs for correlation (<code>meta.request_id</code>) and ISO-8601 timestamps.</li> <li>Define and document each event's payload clearly.</li> <li>Use structured error messages with consistent codes.</li> </ul>"},{"location":"websockets/message-format/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Authentication: Secure your message flows.</li> <li>Clients: Implement this message format on the frontend.</li> <li>Events: Explore supported event types and flows.</li> </ul>"},{"location":"websockets/misc/","title":"Misc","text":""},{"location":"websockets/misc/#overview","title":"Overview","text":"<p>WebSocket is an event-driven, full-duplex asynchronous communications channel for your web applications. It has the ability to give you real-time updates that in the past you would use long polling or other hacks to achieve. The primary benefit is reducing resource needs on both the client and (more important) the server.</p> <p>While WebSocket uses HTTP as the initial transport mechanism, the communication doesn\u2019t end after a response is received by the client. Using the WebSocket API, you can be freed from the constraints of the typical HTTP request/response cycle. This also means that as long as the connection stays open, the client and server can freely send messages asynchronously without polling for anything new.</p>"},{"location":"websockets/misc/#initializing","title":"Initializing","text":"<p>The constructor for WebSocket requires a URL in order to initiate a connection to the server. By default, if no port is specified after the host, it will connect via port <code>80</code> (the HTTP port) or port <code>443</code> (the HTTPS port).</p> <p>For now, because you\u2019ll be running the WebSocket server locally, without a web server proxying the connection, you can simply initialize the browser\u2019s native Web\u2010Socket object with the following code:</p> <pre><code>var ws = new WebSocket(\"ws://localhost:8181\");\n</code></pre> <p>You now have a WebSocket object called ws that you can use to listen for events. The section \u201cWebSocket Events\u201d on page 12 details various events available to listen for. Table 2-1 lists the constructor parameters available with WebSocket.</p> <p>Table 2-1. WebSocket Constructor Parameters</p> Parameter Name Description <code>URL</code> <code>ws://</code> or <code>wss://</code> (if using TLS) <code>protocol</code> (optional) Parameter specifying subprotocols that may be used as an array or single string"},{"location":"websockets/misc/#websocket-events","title":"WebSocket Events","text":"<p>The API for WebSocket is based around <code>events</code>. This section covers the four events that your stock-ticker code can listen for.</p> <p>WebSocket fires four events, which are available from the JavaScript API and defined by the W3C:</p> <ul> <li>open</li> <li>message</li> <li>error</li> <li>close</li> </ul> <p>With JavaScript, you listen for these events to fire either with the handler <code>on &lt;eventname&gt;</code>, or the <code>addEventListener()</code> method. Your code will provide a callback that will execute every time that event gets fired.</p>"},{"location":"websockets/misc/#event-open","title":"Event: Open","text":"<p>When the WebSocket server responds to the connection request, and the handshake is complete, the <code>open</code> event fires and the connection is established. Once this happens, the server has completed the handshake and is ready to send and receive messages from your client application:</p> <pre><code>// WebSocket connection established\nws.onopen = function (e) {\n  console.log(\"Connection established\");\n  ws.send(JSON.stringify(stock_request));\n};\n</code></pre> <p>From within this handler you can send messages to the server and output the status to the screen, and the connection is ready and available for bidirectional communication. The initial message being sent to the server over WebSocket is the <code>stock_request</code> structure as a JSON string. Your server now knows what stocks you want to get updates on and will send them back to the client in one-second intervals.</p>"},{"location":"websockets/misc/#event-message","title":"Event: Message","text":"<p>After you\u2019ve established a connection to the WebSocket server, it will be available to send messages to (you\u2019ll look at that in <code>\u201cWebSocket Methods\u201d on page 16</code>), and receive messages. The WebSocket API will prepare complete messages to be processed in the <code>onmessage</code> handler.</p> <pre><code>// UI update function\nvar changeStockEntry = function (symbol, originalValue, newValue) {\n  var valElem = $(\"#\" + symbol + \" span\");\n  valElem.html(newValue.toFixed(2));\n  if (newValue &lt; originalValue) {\n    valElem.addClass(\"label-danger\");\n    valElem.removeClass(\"label-success\");\n  } else if (newValue &gt; originalValue) {\n    valElem.addClass(\"label-success\");\n    valElem.removeClass(\"label-danger\");\n  }\n};\n\n// WebSocket message handler\nws.onmessage = function (e) {\n  var stocksData = JSON.parse(e.data);\n  for (var symbol in stocksData) {\n    if (stocksData.hasOwnProperty(symbol)) {\n      changeStockEntry(symbol, stocks[symbol], stocksData[symbol]);\n      stocks[symbol] = stocksData[symbol];\n    }\n  }\n};\n</code></pre> <p>You can see from this short snippet that the handler is receiving a message from the server via an <code>onmessage</code> callback. When querying for data, the data attribute will contain updated stock values. The preceding code snippet does the following:</p> <ol> <li>Parses the JSON response within <code>e.data</code></li> <li>Iterates over the associative array</li> <li>Ensures that the key exists in the array</li> <li>Calls your UI update fragment</li> <li>Assigns the new stock values to your local array</li> </ol> <p>You\u2019re passing around regular strings here, but WebSocket has full support for sending text and binary data.</p>"},{"location":"websockets/misc/#event-error","title":"Event: Error","text":"<p>When a failure happens for any reason at all, the handler you\u2019ve attached to the <code>error</code> event gets fired. When an error occurs, it can be assumed that the WebSocket connection will close and a close event will fire. Because the close event happens shortly after an error in some instances, the code and reason attributes can give you some indication as to what happened. Here\u2019s a sample of how to handle the error case, and possibly reconnect to the WebSocket server as well:</p> <pre><code>ws.onerror = function (e) {\n  console.log(\"WebSocket failure, error\", e);\n  handleErrors(e);\n};\n</code></pre>"},{"location":"websockets/misc/#event-pingpong","title":"Event: PING/PONG","text":"<p>The WebSocket protocol calls out two frame types:</p> <ol> <li><code>PING</code> &amp;</li> <li><code>PONG</code>.</li> </ol> <p>The WebSocket JavaScript client API provides no capability to send a <code>PING</code> frame to the server. <code>PING</code> frames are sent out by the server only, and browser implementations should send back PONG frames in response.</p>"},{"location":"websockets/misc/#event-close","title":"Event: Close","text":"<p>The close event fires when the WebSocket connection closes, and the callback onerror will be executed. You can manually trigger calling the <code>onclose</code> event by executing the <code>close()</code> method on a WebSocket object, which will terminate the connection with the server. Once the connection is closed, communication between client and server will not continue. The following example zeros out the stocks array upon a close event being fired to show cleaning up resources:</p> <pre><code>ws.onclose = function (e) {\n  console.log(e.reason + \" \" + e.code);\n  for (var symbol in stocks) {\n    if (stocks.hasOwnProperty(symbol)) {\n      stocks[symbol] = 0;\n    }\n  }\n};\n\nws.close(1000, \"WebSocket connection closed\");\n</code></pre> <p>As mentioned briefly in <code>\u201cEvent: Error\u201d on page 15</code>, two attributes, code and reason, are conveyed by the server and could indicate an error condition to be handled and/or a reason for the close event (other than normal expectation). Either side may terminate the connection via the close() method on the WebSocket object, as shown in the preceding code. Your code can also use the boolean attribute wasClean to find out if the termination was clean, or to see the result of an error state.</p> <p>The <code>readyState</code> value will move from closing (2) to closed (3). Now let\u2019s move on to the methods available to your WebSocket object.</p>"},{"location":"websockets/misc/#websocket-methods","title":"WebSocket Methods","text":"<p>The creators of WebSocket kept its methods pretty simple\u2014there are only two:</p> <ol> <li><code>send()</code> &amp;</li> <li><code>close()</code>.</li> </ol>"},{"location":"websockets/misc/#method-send","title":"Method: Send","text":"<p>When your connection has been established, you\u2019re ready to start sending (and receiving) messages to/from the WebSocket server. The client application can specify what type of data is being passed in and will accept several, including string and binary values. As shown earlier, the client code is sending a JSON string of listed stocks:</p> <pre><code>ws.send(JSON.stringify(stock_request));\n</code></pre> <p>Of course, performing this send just anywhere won\u2019t be appropriate. As we\u2019ve discussed, WebSocket is event-driven, so you need to ensure that the connection is open and ready to receive messages. You can achieve this in two main ways.</p> <p>You can perform your send from within the <code>onopen</code> event:</p> <pre><code>var ws = new WebSocket(\"ws://localhost:8181\");\nws.onopen = function (e) {\n  ws.send(JSON.stringify(stock_request));\n};\n</code></pre> <p>Or you can check the <code>readyState</code> attribute to ensure that the WebSocket object is ready to receive messages:</p> <pre><code>function processEvent(e) {\n  if (ws.readyState === WebSocket.OPEN) {\n    // Socket open, send!\n    ws.send(e);\n  } else {\n    // Show an error, queue it for sending later, etc\n  }\n}\n</code></pre>"},{"location":"websockets/misc/#method-close","title":"Method: Close","text":"<p>You close the WebSocket connection or terminate an attempt at connection is done via the <code>close()</code> method. After this method is called, no more data can be sent or received from this connection. And calling it multiple times has no effect.</p> <p>Here\u2019s an example of calling the close() method without arguments:</p> <pre><code>// Close WebSocket connection\nws.close();\n</code></pre> <p>Optionally, you can pass a numeric code and a human-readable reason through the <code>close()</code> method. This gives some indication to the server as to why the connection was closed on the client end. The following code shows how to pass those values.</p> <p>Note that if you don\u2019t pass a code, the status 1000 is assumed, which means CLOSE_NORMAL:</p> <pre><code>// Close the WebSocket connection with reason.\nws.close(1000, \"Goodbye, World!\");\n</code></pre> <p>Table 2-2 lists the status codes you can use in the WebSocket <code>close()</code> method.</p>"},{"location":"websockets/misc/#table-2-2-websocket-close-codes","title":"Table 2-2. WebSocket Close Codes","text":"Status Code Name Description 0\u2013999 \u2014 Reserved and not used. 1000 <code>CLOSE_NORMAL</code> Normal closure; the connection successfully completed. 1001 <code>CLOSE_GOING_AWAY</code> The endpoint is going away, either because of a server failure or because the browser is navigating away. 1002 <code>CLOSE_PROTOCOL_ERROR</code> The endpoint is terminating the connection due to a protocol error. 1003 <code>CLOSE_UNSUPPORTED</code> The connection is being terminated because the endpoint received data of a type it cannot accept. 1004 <code>CLOSE_TOO_LARGE</code> The endpoint is terminating the connection because a data frame was received that is too large. 1005 <code>CLOSE_NO_STATUS</code> Reserved. Indicates that no status code was provided even though one was expected. 1006 <code>CLOSE_ABNORMAL</code> Reserved. Used to indicate that a connection was closed abnormally. 1007\u20131999 \u2014 Reserved for future use by the WebSocket standard. 2000\u20132999 \u2014 Reserved for use by WebSocket extensions. 3000\u20133999 \u2014 Available for use by libraries and frameworks. May not be used by applications. 4000\u20134999 \u2014 Available for use by applications."},{"location":"websockets/misc/#websocket-attributes","title":"WebSocket Attributes","text":"<p>When the event for <code>open</code> is fired, the WebSocket object can have several possible attributes that can be read in your client applications. This section presents the attributes and the best practices for using them in your client code.</p>"},{"location":"websockets/misc/#attribute-readystate","title":"Attribute: readyState","text":"<p>The state of the WebSocket connection can be checked via the read-only WebSocket object attribute <code>readyState</code>. The value of <code>readyState</code> will change, and it is a good idea to check it before committing to send any data to the server.</p>"},{"location":"websockets/misc/#attribute-bufferedamount","title":"Attribute: bufferedAmount","text":""},{"location":"websockets/misc/#attribute-protocol","title":"Attribute: protocol","text":"Stock Example Server<pre><code>var WebSocketServer = require(\"ws\").Server,\n  wss = new WebSocketServer({ port: 8181 });\n\nvar stocks = {\n  AAPL: 95.0,\n  MSFT: 50.0,\n  AMZN: 300.0,\n  GOOG: 550.0,\n  YHOO: 35.0,\n};\n\nfunction randomInterval(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nvar stockUpdater;\n\nvar randomStockUpdater = function () {\n  for (var symbol in stocks) {\n    if (stocks.hasOwnProperty(symbol)) {\n      var randomizedChange = randomInterval(-150, 150);\n      var floatChange = randomizedChange / 100;\n      stocks[symbol] += floatChange;\n    }\n  }\n\n  var randomMSTime = randomInterval(500, 2500);\n\n  stockUpdater = setTimeout(function () {\n    randomStockUpdater();\n  }, randomMSTime);\n};\n\nrandomStockUpdater();\n\nwss.on(\"connection\", function (ws) {\n  var clientStockUpdater;\n\n  var sendStockUpdates = function (ws) {\n    if (ws.readyState == 1) {\n      var stocksObj = {};\n      for (var i = 0; i &lt; clientStocks.length; i++) {\n        symbol = clientStocks[i];\n        stocksObj[symbol] = stocks[symbol];\n      }\n      ws.send(JSON.stringify(stocksObj));\n    }\n  };\n\n  clientStockUpdater = setInterval(function () {\n    sendStockUpdates(ws);\n  }, 1000);\n\n  var clientStocks = [];\n\n  ws.on(\"message\", function (message) {\n    var stock_request = JSON.parse(message);\n    clientStocks = stock_request[\"stocks\"];\n    sendStockUpdates(ws);\n  });\n\n  ws.on(\"close\", function () {\n    if (typeof clientStockUpdater !== \"undefined\") {\n      clearInterval(clientStockUpdater);\n    }\n  });\n});\n</code></pre>"},{"location":"websockets/misc/#testing-for-websocket-support","title":"Testing for WebSocket Support","text":"<p>If you\u2019ve coded anything for the Web over the years, it should come as no surprise that browsers do not always have support for the latest technology. Because some older browsers don\u2019t support the WebSocket API, it is important to check for compatibility before using it.</p> <p><code>Chapter 5</code> presents alternatives if the client browsers used by your community of users don\u2019t support the WebSocket API. For now, here is a quick way to check whether the API is supported on the client:</p> <pre><code>if (window.WebSocket) {\n  console.log(\"WebSocket: supported\");\n  // ... code here for doing WebSocket stuff\n} else {\n  console.log(\"WebSocket: unsupported\");\n  // ... fallback mode, or error back to user\n}\n</code></pre>"},{"location":"websockets/misc/#reference","title":"Reference","text":"<ul> <li>WebSocket by Andrew Lombardi</li> </ul>"},{"location":"websockets/overview/","title":"Overview","text":""},{"location":"websockets/overview/#websockets-overview","title":"WebSockets Overview","text":"<p>WebSockets provide a full-duplex communication channel over a single, long-lived connection between client and server. Unlike HTTP, which is request/response-based, WebSockets enable real-time data transfer without repeated polling.</p> <p>This page introduces WebSockets, their advantages, and how they fit into modern backend systems.</p>"},{"location":"websockets/overview/#what-is-a-websocket","title":"\ud83d\udd04 What is a WebSocket?","text":"<p>A WebSocket is a persistent connection between a client (e.g., browser or mobile app) and server, established through a single HTTP handshake and upgraded to a TCP-based protocol. Once connected, either party can send data at any time.</p> <p>Key properties:</p> <ul> <li>Full-duplex: Both client and server can communicate simultaneously.</li> <li>Low latency: Ideal for real-time features like chat, notifications, games, or live dashboards.</li> <li>Persistent: The connection remains open, reducing handshake overhead.</li> </ul>"},{"location":"websockets/overview/#why-use-websockets","title":"\u2705 Why Use WebSockets?","text":"Use Case Description Chat applications Real-time message delivery and status updates Live notifications Push alerts to users instantly Online gaming Low-latency interactions between players Collaborative tools Shared state updates (e.g., whiteboards, code editors) IoT dashboards Stream data from sensors in real-time"},{"location":"websockets/overview/#how-it-works","title":"\ud83d\udd27 How It Works","text":"<ol> <li>Client initiates a connection with a special HTTP request:</li> </ol> <pre><code>GET /ws HTTP/1.1\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\n</code></pre> <ol> <li>Server responds with a status indicating a successful upgrade:</li> </ol> <pre><code>HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\n</code></pre> <ol> <li>Communication begins over the new WebSocket protocol.</li> </ol> <p>Both the client and server can now send JSON, binary, or text data over the connection.</p>"},{"location":"websockets/overview/#common-backend-implementations","title":"\ud83d\udcda Common Backend Implementations","text":"Framework WebSocket Support FastAPI Native via <code>WebSocket</code> and <code>async</code> endpoints Django Via Channels and <code>ASGI</code> Node.js With <code>ws</code>, <code>socket.io</code>, or <code>uWebSockets.js</code> Go Via <code>gorilla/websocket</code> or <code>nhooyr.io/websocket</code> Rust Libraries like <code>tokio-tungstenite</code> or <code>warp</code>"},{"location":"websockets/overview/#protocol-design-high-level","title":"\ud83d\udce6 Protocol Design (High-Level)","text":"<p>While WebSocket is a transport protocol, you typically define your application-level protocol over it.</p> <p>Example message format:</p> <pre><code>{\n  \"event\": \"join_room\",\n  \"data\": {\n    \"room_id\": \"abc123\",\n    \"user_id\": \"user789\"\n  }\n}\n</code></pre> <p>This allows you to structure interactions as event-based messages (see Message Format).</p>"},{"location":"websockets/overview/#limitations","title":"\ud83d\udea8 Limitations","text":"<ul> <li>Requires fallback support if WebSockets are blocked (e.g., corporate firewalls)</li> <li>Connection management is more complex (e.g., reconnection, heartbeat, scaling)</li> <li>No built-in message delivery guarantees (you must handle retries/acks)</li> </ul>"},{"location":"websockets/overview/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<p>Explore the following sections to learn how to structure, secure, and integrate WebSockets:</p> <ul> <li>Message Format</li> <li>Authentication</li> <li>Clients</li> <li>Integrations with FastAPI and Django Channels</li> </ul>"},{"location":"websockets/clients/javascript/","title":"JavaScript","text":""},{"location":"websockets/clients/javascript/#websocket-clients-javascript","title":"WebSocket Clients: JavaScript","text":"<p>This guide explains how to create, manage, and secure a WebSocket client in modern JavaScript. It includes connection setup, message handling, reconnection logic, and best practices for real-time apps.</p>"},{"location":"websockets/clients/javascript/#1-basic-websocket-client","title":"\ud83d\ude80 1. Basic WebSocket Client","text":"<pre><code>const socket = new WebSocket(\"wss://your-api.com/ws\");\n\nsocket.onopen = () =&gt; {\n  console.log(\"Connected to WebSocket\");\n};\n\nsocket.onmessage = (event) =&gt; {\n  const msg = JSON.parse(event.data);\n  handleMessage(msg);\n};\n\nsocket.onclose = (event) =&gt; {\n  console.log(\"Disconnected:\", event.code, event.reason);\n};\n\nsocket.onerror = (error) =&gt; {\n  console.error(\"WebSocket error:\", error);\n};\n</code></pre>"},{"location":"websockets/clients/javascript/#2-sending-messages","title":"\ud83d\udce8 2. Sending Messages","text":"<p>Always follow your backend\u2019s message format (e.g. include <code>type</code> and <code>data</code>).</p> <pre><code>function sendMessage(type, data) {\n  const message = {\n    type,\n    data,\n    meta: {\n      request_id: crypto.randomUUID(),\n      timestamp: new Date().toISOString(),\n    },\n  };\n  socket.send(JSON.stringify(message));\n}\n</code></pre> <p>Example:</p> <pre><code>sendMessage(\"send_message\", {\n  room_id: \"chat-room-1\",\n  message: \"Hello world!\",\n});\n</code></pre>"},{"location":"websockets/clients/javascript/#3-reconnection-logic","title":"\ud83d\udd01 3. Reconnection Logic","text":"<p>Add automatic reconnection with exponential backoff.</p> <pre><code>let reconnectAttempts = 0;\n\nfunction connect() {\n  const ws = new WebSocket(\"wss://your-api.com/ws?token=YOUR_TOKEN\");\n\n  ws.onopen = () =&gt; {\n    reconnectAttempts = 0;\n    console.log(\"WebSocket connected\");\n  };\n\n  ws.onclose = (event) =&gt; {\n    console.warn(\"WebSocket closed:\", event.code);\n    const timeout = Math.min(1000 * 2 ** reconnectAttempts, 30000);\n    setTimeout(connect, timeout);\n    reconnectAttempts++;\n  };\n\n  ws.onmessage = (event) =&gt; {\n    const msg = JSON.parse(event.data);\n    handleMessage(msg);\n  };\n\n  ws.onerror = (e) =&gt; console.error(\"WebSocket error:\", e);\n}\n\nconnect();\n</code></pre>"},{"location":"websockets/clients/javascript/#4-authentication","title":"\ud83d\udd10 4. Authentication","text":"<p>Most secure apps use a token in the query string or send an auth message after connection:</p> <p>With token in URL:</p> <pre><code>const token = getTokenFromStorage();\nconst socket = new WebSocket(`wss://your-api.com/ws?token=${token}`);\n</code></pre> <p>Or: send token in first message:</p> <pre><code>socket.onopen = () =&gt; {\n  sendMessage(\"auth\", { token });\n};\n</code></pre>"},{"location":"websockets/clients/javascript/#5-handling-server-messages","title":"\ud83e\udde0 5. Handling Server Messages","text":"<p>Structure your message handler based on <code>type</code>.</p> <pre><code>function handleMessage(msg) {\n  switch (msg.type) {\n    case \"connection_established\":\n      console.log(\"Connected:\", msg.data);\n      break;\n    case \"new_message\":\n      displayChatMessage(msg.data);\n      break;\n    case \"user_typing\":\n      showTypingIndicator(msg.data.user_id);\n      break;\n    case \"error\":\n      alert(\"Error: \" + msg.data.message);\n      break;\n    default:\n      console.warn(\"Unknown event type:\", msg.type);\n  }\n}\n</code></pre>"},{"location":"websockets/clients/javascript/#6-debugging-tips","title":"\ud83e\uddea 6. Debugging Tips","text":"<ul> <li>Use browser DevTools \u2192 Network &gt; WS tab to inspect messages.</li> <li>Log all <code>onmessage</code> and <code>onerror</code> events during development.</li> <li>Retry connections only after handling auth or network errors properly.</li> <li>Throttle reconnection attempts to avoid flooding the server.</li> </ul>"},{"location":"websockets/clients/javascript/#7-best-practices","title":"\u2705 7. Best Practices","text":"<ul> <li>Always use <code>wss://</code> in production for encryption.</li> <li>Abstract socket logic into a reusable class or hook.</li> <li>Handle all close codes gracefully (e.g., <code>1008</code> for auth failure).</li> <li>Implement ping/pong logic if required by the backend.</li> <li>Track connection state for UI updates (e.g., loading spinners, reconnect notices).</li> </ul>"},{"location":"websockets/clients/javascript/#8-optional-websocket-wrapper-class","title":"\ud83d\udce6 8. Optional: WebSocket Wrapper Class","text":"<pre><code>class WSClient {\n  constructor(url) {\n    this.url = url;\n    this.connect();\n  }\n\n  connect() {\n    this.ws = new WebSocket(this.url);\n    this.ws.onopen = () =&gt; console.log(\"Connected\");\n    this.ws.onclose = () =&gt; setTimeout(() =&gt; this.connect(), 3000);\n    this.ws.onmessage = (e) =&gt; this.onMessage(JSON.parse(e.data));\n    this.ws.onerror = (e) =&gt; console.error(e);\n  }\n\n  send(type, data) {\n    this.ws.send(JSON.stringify({ type, data }));\n  }\n\n  onMessage(msg) {\n    console.log(\"Received:\", msg);\n    // Dispatch to handlers here\n  }\n}\n</code></pre>"},{"location":"websockets/clients/javascript/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Message Format: Follow the standardized structure for all messages.</li> <li>Authentication: Secure your WebSocket sessions.</li> <li>Disconnection Handling: Manage graceful reconnections and state.</li> </ul>"},{"location":"websockets/clients/python/","title":"Python","text":""},{"location":"websockets/clients/python/#websocket-clients-python","title":"WebSocket Clients: Python","text":"<p>This guide covers how to create and manage WebSocket clients in Python, suitable for backend services, scripts, or CLI tools that interact with WebSocket servers.</p>"},{"location":"websockets/clients/python/#1-using-websockets-library","title":"\ud83d\ude80 1. Using <code>websockets</code> Library","text":"<p>The <code>websockets</code> library is a popular choice for Python WebSocket clients and servers.</p>"},{"location":"websockets/clients/python/#installation","title":"Installation","text":"<pre><code>pip install websockets\n</code></pre>"},{"location":"websockets/clients/python/#2-basic-client-example","title":"\ud83c\udfd7 2. Basic Client Example","text":"<pre><code>import asyncio\nimport websockets\nimport json\n\nasync def websocket_client():\n    uri = \"wss://your-api.com/ws?token=YOUR_TOKEN\"\n    async with websockets.connect(uri) as websocket:\n        # Send a message\n        message = {\n            \"type\": \"auth\",\n            \"data\": {\"token\": \"YOUR_TOKEN\"}\n        }\n        await websocket.send(json.dumps(message))\n\n        # Receive messages\n        async for message in websocket:\n            msg = json.loads(message)\n            await handle_message(msg)\n\nasync def handle_message(msg):\n    event_type = msg.get(\"type\")\n    data = msg.get(\"data\", {})\n    if event_type == \"connection_established\":\n        print(f\"Connected as user {data.get('user_id')}\")\n    elif event_type == \"new_message\":\n        print(f\"New message: {data.get('message')}\")\n    elif event_type == \"error\":\n        print(f\"Error {data.get('code')}: {data.get('message')}\")\n    else:\n        print(f\"Unhandled message: {msg}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(websocket_client())\n</code></pre>"},{"location":"websockets/clients/python/#3-reconnection-logic-with-exponential-backoff","title":"\ud83d\udd01 3. Reconnection Logic with Exponential Backoff","text":"<pre><code>import asyncio\nimport json\nimport websockets\nimport random\n\nasync def connect_with_retries(uri, max_retries=5):\n    retries = 0\n    while retries &lt; max_retries:\n        try:\n            async with websockets.connect(uri) as websocket:\n                print(\"WebSocket connected\")\n                await websocket.send(json.dumps({\"type\": \"auth\", \"data\": {\"token\": \"YOUR_TOKEN\"}}))\n                async for message in websocket:\n                    msg = json.loads(message)\n                    await handle_message(msg)\n        except (websockets.ConnectionClosed, ConnectionRefusedError) as e:\n            wait_time = (2 ** retries) + random.random()\n            print(f\"Connection lost: {e}. Reconnecting in {wait_time:.1f} seconds...\")\n            await asyncio.sleep(wait_time)\n            retries += 1\n    print(\"Max retries reached. Exiting.\")\n\nasync def handle_message(msg):\n    print(f\"Received message: {msg}\")\n\nif __name__ == \"__main__\":\n    uri = \"wss://your-api.com/ws?token=YOUR_TOKEN\"\n    asyncio.run(connect_with_retries(uri))\n</code></pre>"},{"location":"websockets/clients/python/#4-authentication","title":"\ud83d\udd10 4. Authentication","text":"<p>Pass tokens either via query parameters in the URI or send an authentication message immediately after connecting.</p> <pre><code># Option 1: Token in URI (shown above)\n\n# Option 2: Send auth message after connecting\nawait websocket.send(json.dumps({\n    \"type\": \"auth\",\n    \"data\": {\"token\": \"YOUR_TOKEN\"}\n}))\n</code></pre>"},{"location":"websockets/clients/python/#5-handling-server-messages","title":"\ud83e\udde0 5. Handling Server Messages","text":"<p>Implement a dispatcher based on the <code>type</code> field:</p> <pre><code>async def handle_message(msg):\n    event_type = msg.get(\"type\")\n    data = msg.get(\"data\", {})\n\n    if event_type == \"connection_established\":\n        print(f\"Connected as user {data.get('user_id')}\")\n    elif event_type == \"new_message\":\n        print(f\"Message: {data.get('message')}\")\n    elif event_type == \"error\":\n        print(f\"Error {data.get('code')}: {data.get('message')}\")\n    else:\n        print(f\"Unknown event type: {event_type}\")\n</code></pre>"},{"location":"websockets/clients/python/#6-debugging-tips","title":"\ud83e\uddea 6. Debugging Tips","text":"<ul> <li>Enable logging for the <code>websockets</code> library:</li> </ul> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre> <ul> <li>Use Wireshark or other network tools to inspect traffic.</li> <li>Handle exceptions gracefully to avoid client crashes.</li> <li>Test with invalid messages to ensure error handling works.</li> </ul>"},{"location":"websockets/clients/python/#7-best-practices","title":"\u2705 7. Best Practices","text":"<ul> <li>Use secure WebSocket connections (<code>wss://</code>) in production.</li> <li>Implement reconnect logic with backoff to handle network issues.</li> <li>Validate and sanitize incoming messages.</li> <li>Log errors and connection events for observability.</li> <li>Cleanly close connections when shutting down.</li> </ul>"},{"location":"websockets/clients/python/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Message Format: Use standardized message envelopes.</li> <li>Authentication: Secure your client sessions.</li> <li>Error Handling: Manage errors gracefully.</li> </ul>"},{"location":"websockets/clients/tools/","title":"Postman/WebSocket Clients","text":""},{"location":"websockets/clients/tools/#websocket-clients-postman-other-tools","title":"WebSocket Clients: Postman &amp; Other Tools","text":"<p>Testing and interacting with WebSocket APIs is easier with dedicated tools. This page covers how to use Postman, browser extensions, and standalone apps to connect, send, and debug WebSocket traffic.</p>"},{"location":"websockets/clients/tools/#1-postman-websocket-support","title":"\ud83d\udee0 1. Postman WebSocket Support","text":"<p>Postman supports WebSocket connections for testing real-time APIs.</p>"},{"location":"websockets/clients/tools/#connecting","title":"Connecting","text":"<ol> <li>Open Postman.</li> <li>Click New \u2192 WebSocket Request.</li> <li>Enter your WebSocket URL (e.g., <code>wss://your-api.com/ws?token=YOUR_TOKEN</code>).</li> <li>Click Connect.</li> </ol>"},{"location":"websockets/clients/tools/#sending-messages","title":"Sending Messages","text":"<ul> <li>Compose messages in JSON format.</li> <li>Use the Send button to transmit.</li> <li>View server responses in the message log.</li> </ul>"},{"location":"websockets/clients/tools/#features","title":"Features","text":"<ul> <li>Save WebSocket requests for reuse.</li> <li>View full message history.</li> <li>Supports ping/pong and close frames.</li> <li>Inspect connection status and events.</li> </ul>"},{"location":"websockets/clients/tools/#2-browser-extensions","title":"\ud83c\udf10 2. Browser Extensions","text":"<p>Popular WebSocket client extensions include:</p> <ul> <li>Simple WebSocket Client (Chrome)</li> <li>WebSocket King Client (Chrome/Firefox)</li> </ul> <p>Features:</p> <ul> <li>Easy UI to connect/disconnect.</li> <li>Send/receive JSON or plain text.</li> <li>View detailed message logs.</li> <li>Support for custom headers and authentication tokens.</li> </ul>"},{"location":"websockets/clients/tools/#3-standalone-apps","title":"\ud83d\udcbb 3. Standalone Apps","text":"<ul> <li>wscat (CLI tool):</li> </ul> <pre><code>npm install -g wscat\nwscat -c wss://your-api.com/ws?token=YOUR_TOKEN\n</code></pre> <ul> <li> <p>Insomnia:</p> </li> <li> <p>Supports WebSocket requests similar to Postman.</p> </li> <li> <p>Good for combining REST and WebSocket testing.</p> </li> <li> <p>Smart WebSocket Client (Chrome):</p> </li> <li> <p>Lightweight extension with intuitive UI.</p> </li> <li>Supports multiple connections.</li> </ul>"},{"location":"websockets/clients/tools/#4-tips-for-testing-websocket-apis","title":"\ud83d\udcdd 4. Tips for Testing WebSocket APIs","text":"<ul> <li>Always test connection establishment before sending messages.</li> <li>Validate error handling by sending malformed payloads.</li> <li>Test reconnection by manually disconnecting.</li> <li>Use timestamps or unique IDs in messages to trace flows.</li> <li>Monitor network traffic with browser DevTools \u2192 Network \u2192 WS tab.</li> </ul>"},{"location":"websockets/clients/tools/#5-summary","title":"\u2705 5. Summary","text":"Tool Platform Key Features Postman Desktop/Web Saved requests, message history Simple WebSocket Client Browser extension Easy connect/disconnect wscat CLI Lightweight, scriptable Insomnia Desktop Multi-protocol support"},{"location":"websockets/clients/tools/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>JavaScript Client: Build a WebSocket client in the browser.</li> <li>Error Handling: Test how your API responds to errors.</li> <li>Authentication: Pass tokens securely in your tests.</li> </ul>"},{"location":"websockets/events/connection/","title":"Connection","text":""},{"location":"websockets/events/connection/#websocket-events-connection-lifecycle","title":"WebSocket Events: Connection Lifecycle","text":"<p>This section describes how WebSocket connections are initiated, maintained, and terminated. Understanding the lifecycle events is critical for managing real-time sessions and user state effectively.</p>"},{"location":"websockets/events/connection/#1-connection-open","title":"\ud83d\udd0c 1. Connection Open","text":"<p>When a client initiates a WebSocket connection, the server must decide whether to accept or reject the request.</p>"},{"location":"websockets/events/connection/#client-server","title":"Client \u2192 Server","text":"<ul> <li>Initiates connection via <code>new WebSocket()</code> or equivalent.</li> <li>Optionally provides query parameters (e.g., token) for authentication.</li> </ul>"},{"location":"websockets/events/connection/#server-actions","title":"Server Actions","text":"<ul> <li>Validate the client (e.g., auth token).</li> <li>Accept the connection using <code>websocket.accept()</code>.</li> <li>Optionally send an acknowledgment message.</li> </ul> <p>Example:</p> <pre><code>{\n  \"type\": \"connection_established\",\n  \"data\": {\n    \"user_id\": \"abc123\",\n    \"timestamp\": \"2025-08-04T12:00:00Z\"\n  }\n}\n</code></pre>"},{"location":"websockets/events/connection/#server-side-fastapi","title":"Server-side (FastAPI):","text":"<pre><code>@app.websocket(\"/ws\")\nasync def connect(websocket: WebSocket):\n    await websocket.accept()\n    await websocket.send_json({\n        \"type\": \"connection_established\",\n        \"data\": {\n            \"user_id\": \"abc123\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    })\n</code></pre>"},{"location":"websockets/events/connection/#2-heartbeats-pingpong","title":"\u2764\ufe0f 2. Heartbeats (Ping/Pong)","text":"<p>To detect broken connections or idle clients, many systems use ping/pong messages.</p> <p>Client-side (Optional):</p> <pre><code>{\n  \"type\": \"ping\"\n}\n</code></pre> <p>Server Response:</p> <pre><code>{\n  \"type\": \"pong\"\n}\n</code></pre> <p>Or vice versa\u2014some servers send <code>ping</code>, and clients respond with <code>pong</code>.</p> <p>Purpose:</p> <ul> <li>Detect disconnected clients.</li> <li>Prevent idle timeouts (common on load balancers and proxies).</li> <li>Keep connections alive in backgrounded apps.</li> </ul>"},{"location":"websockets/events/connection/#3-connection-close","title":"\u274c 3. Connection Close","text":"<p>The server or client can choose to close the connection at any time.</p> <p>Server \u2192 Client:</p> <pre><code>{\n  \"type\": \"disconnect\",\n  \"data\": {\n    \"reason\": \"unauthorized\",\n    \"code\": 4003\n  }\n}\n</code></pre> <ul> <li>The server can follow this message with a call to <code>websocket.close(code=4003)</code>.</li> <li>Clients should gracefully handle <code>onclose</code> events.</li> </ul>"},{"location":"websockets/events/connection/#standard-close-codes","title":"Standard Close Codes:","text":"Code Meaning <code>1000</code> Normal closure <code>1008</code> Policy violation (e.g. auth fail) <code>1011</code> Internal error <code>4003</code> Custom code: Unauthorized <code>4004</code> Custom code: Banned / Throttled"},{"location":"websockets/events/connection/#recommended-event-types","title":"\ud83d\udccb Recommended Event Types","text":"Event Type Direction Description <code>connection_established</code> Server \u2192 Client Sent after a successful connection <code>ping</code> Client \u2192 Server Optional heartbeat message <code>pong</code> Server \u2192 Client Response to <code>ping</code> <code>disconnect</code> Server \u2192 Client Server intends to close connection <code>error</code> Server \u2192 Client Fatal connection error or violation"},{"location":"websockets/events/connection/#best-practices","title":"\ud83e\udde0 Best Practices","text":"<ul> <li>Acknowledge successful connections explicitly (e.g., <code>connection_established</code>).</li> <li>Implement ping/pong heartbeats every 30\u201360 seconds.</li> <li>Use close codes consistently for client-side handling.</li> <li>Log all connect/disconnect events on the backend for debugging and metrics.</li> </ul>"},{"location":"websockets/events/connection/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Custom Events: Define your application's business-level messages.</li> <li>Authentication: Secure connections before accepting.</li> <li>Error Handling: Manage failures gracefully.</li> </ul>"},{"location":"websockets/events/custom/","title":"Custom Events","text":""},{"location":"websockets/events/custom/#websocket-events-custom-events","title":"WebSocket Events: Custom Events","text":"<p>Custom events are the heart of any real-time WebSocket application. They define the actions and behaviors your system supports\u2014such as messaging, notifications, typing indicators, room management, and more.</p> <p>This page shows how to design, name, and structure custom events consistently.</p>"},{"location":"websockets/events/custom/#1-what-are-custom-events","title":"\ud83e\uddfe 1. What Are Custom Events?","text":"<p>Custom events are user-defined <code>type</code> values in your WebSocket message format. These represent actions or updates within your application logic.</p> <p>Example:</p> <pre><code>{\n  \"type\": \"user_typing\",\n  \"data\": {\n    \"room_id\": \"abc123\",\n    \"user_id\": \"user456\"\n  }\n}\n</code></pre>"},{"location":"websockets/events/custom/#2-event-naming-conventions","title":"\ud83d\udcda 2. Event Naming Conventions","text":"<p>Use <code>snake_case</code> or <code>kebab-case</code> for consistency. Prefix events based on function or domain when appropriate.</p> Event Type Description <code>send_message</code> User sends a chat message <code>new_message</code> Server broadcasts new message <code>user_typing</code> Indicates a user is typing <code>user_joined</code> A user entered a room/channel <code>user_left</code> A user disconnected or left a room <code>update_profile</code> User updates their profile info <code>reaction_added</code> User adds emoji reaction <p>Avoid overly generic names like <code>event1</code>, <code>update</code>, or <code>message</code>.</p>"},{"location":"websockets/events/custom/#3-sample-event-definitions","title":"\u270d\ufe0f 3. Sample Event Definitions","text":""},{"location":"websockets/events/custom/#send-chat-message","title":"\ud83d\udce8 Send Chat Message","text":"<p>Client \u2192 Server:</p> <pre><code>{\n  \"type\": \"send_message\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"message\": \"Hello, world!\"\n  }\n}\n</code></pre> <p>Server \u2192 All Clients:</p> <pre><code>{\n  \"type\": \"new_message\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"user_id\": \"user123\",\n    \"message\": \"Hello, world!\",\n    \"timestamp\": \"2025-08-04T12:34:56Z\"\n  }\n}\n</code></pre>"},{"location":"websockets/events/custom/#typing-indicator","title":"\u270d\ufe0f Typing Indicator","text":"<p>Client \u2192 Server:</p> <pre><code>{\n  \"type\": \"user_typing\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"user_id\": \"user123\"\n  }\n}\n</code></pre> <p>Server \u2192 Other Clients:</p> <pre><code>{\n  \"type\": \"user_typing\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"user_id\": \"user123\"\n  }\n}\n</code></pre>"},{"location":"websockets/events/custom/#user-joinleave-notifications","title":"\ud83d\ude4b User Join/Leave Notifications","text":"<p>Join:</p> <pre><code>{\n  \"type\": \"user_joined\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"user_id\": \"user123\",\n    \"username\": \"johndoe\"\n  }\n}\n</code></pre> <p>Leave:</p> <pre><code>{\n  \"type\": \"user_left\",\n  \"data\": {\n    \"room_id\": \"room-abc\",\n    \"user_id\": \"user123\"\n  }\n}\n</code></pre>"},{"location":"websockets/events/custom/#4-backend-routing-of-custom-events","title":"\ud83d\udee0 4. Backend Routing of Custom Events","text":"<p>Use a dispatcher or router to handle incoming <code>type</code> fields.</p> Example (Python)<pre><code>event_handlers = {\n    \"send_message\": handle_send_message,\n    \"user_typing\": handle_user_typing,\n    \"update_profile\": handle_update_profile,\n}\n\nasync def handle_message(message: dict, websocket):\n    event_type = message.get(\"type\")\n    handler = event_handlers.get(event_type)\n\n    if handler:\n        await handler(message[\"data\"], websocket)\n    else:\n        await websocket.send_json({\n            \"type\": \"error\",\n            \"data\": {\"message\": f\"Unsupported event: {event_type}\"}\n        })\n</code></pre>"},{"location":"websockets/events/custom/#best-practices","title":"\u2705 Best Practices","text":"<ul> <li>Validate payloads per event type (e.g., using Pydantic or JSON Schema).</li> <li>Broadcast efficiently using rooms, channels, or groups.</li> <li>Document each event and its expected <code>data</code> shape.</li> <li>Avoid overloading one event type with multiple functions.</li> <li>Version carefully if events change shape over time.</li> </ul>"},{"location":"websockets/events/custom/#event-testing-tips","title":"\ud83e\uddea Event Testing Tips","text":"<ul> <li>Use Postman or browser dev tools with raw WebSocket clients.</li> <li>Mock client messages to simulate edge cases.</li> <li>Log unhandled <code>type</code> values on the server.</li> <li>Add integration tests to verify each custom event\u2019s round trip.</li> </ul>"},{"location":"websockets/events/custom/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Clients: Learn how to emit and handle custom events in the frontend.</li> <li>Message Format: Review the standard envelope used in all events.</li> <li>Error Handling: Gracefully manage unknown or malformed event types.</li> </ul>"},{"location":"websockets/events/disconnection/","title":"Disconnection","text":""},{"location":"websockets/events/disconnection/#websocket-events-disconnection","title":"WebSocket Events: Disconnection","text":"<p>Disconnections are a normal part of any WebSocket system. They can occur for many reasons\u2014user-initiated, server-initiated, timeouts, or network failures. Handling these cleanly is essential for a reliable real-time experience.</p>"},{"location":"websockets/events/disconnection/#1-why-disconnections-happen","title":"\ud83d\udd1a 1. Why Disconnections Happen","text":"<p>Disconnections can occur due to:</p> <ul> <li>User navigates away or closes the browser.</li> <li>Server closes the connection (e.g., due to auth failure, idle timeout, maintenance).</li> <li>Network issues (e.g., mobile devices switching networks).</li> <li>Application-level logic (e.g., user kicked from a room).</li> </ul>"},{"location":"websockets/events/disconnection/#2-server-initiated-disconnects","title":"\ud83e\udde0 2. Server-Initiated Disconnects","text":"<p>When the server decides to disconnect a client, it should first send a message (if possible) explaining why.</p> <p>Example:</p> <pre><code>{\n  \"type\": \"disconnect\",\n  \"data\": {\n    \"reason\": \"unauthorized\",\n    \"code\": 4003\n  }\n}\n</code></pre> <p>Then:</p> <pre><code>await websocket.close(code=4003)\n</code></pre>"},{"location":"websockets/events/disconnection/#common-reasons","title":"Common Reasons","text":"Code Reason <code>1008</code> Policy violation <code>4001</code> Inactivity timeout <code>4003</code> Unauthorized <code>4004</code> Rate limit / Ban"},{"location":"websockets/events/disconnection/#3-client-initiated-disconnects","title":"\ud83d\udc4b 3. Client-Initiated Disconnects","text":"<p>Clients may close the connection voluntarily:</p> <ul> <li>Logging out</li> <li>Navigating away from the app</li> <li>Closing a chat or room</li> </ul> <p>Client Example (JS):</p> <pre><code>socket.close(1000, \"User logged out\");\n</code></pre>"},{"location":"websockets/events/disconnection/#4-detecting-disconnection-on-server","title":"\ud83d\udca1 4. Detecting Disconnection on Server","text":"<p>In many frameworks (e.g., FastAPI, Django Channels), you can catch a disconnect with an exception:</p> FastAPI Example<pre><code>try:\n    while True:\n        data = await websocket.receive_text()\n        # handle message\nexcept WebSocketDisconnect:\n    # Clean up resources, notify other users, etc.\n    await handle_disconnect(user_id)\n</code></pre>"},{"location":"websockets/events/disconnection/#5-reconnection-strategies","title":"\ud83d\udd04 5. Reconnection Strategies","text":"<p>Your frontend should attempt reconnection when appropriate:</p> <pre><code>socket.onclose = (event) =&gt; {\n  if (event.code !== 1000) {\n    setTimeout(() =&gt; {\n      reconnectSocket();\n    }, 3000); // backoff\n  }\n};\n</code></pre> <p>You can use exponential backoff, session resume tokens, or persistent client IDs to restore user state after reconnecting.</p>"},{"location":"websockets/events/disconnection/#disconnection-event-summary","title":"\ud83d\udccb Disconnection Event Summary","text":"Event Type Direction Description <code>disconnect</code> Server \u2192 Client Server intends to close connection <code>onclose</code> Browser Event Fired when connection closes <code>WebSocketDisconnect</code> Server Exception Triggered when client disconnects"},{"location":"websockets/events/disconnection/#best-practices","title":"\u2705 Best Practices","text":"<ul> <li>Always send a final <code>disconnect</code> event when closing a connection server-side (if time permits).</li> <li>Use proper close codes so clients can act appropriately.</li> <li>Clean up user state (rooms, sessions, database locks) after disconnects.</li> <li>Reconnect intelligently\u2014don\u2019t hammer the server on failure.</li> <li>Log all disconnects with reasons and codes for observability.</li> </ul>"},{"location":"websockets/events/disconnection/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Custom Events: Handle app-specific events like <code>user_left</code>.</li> <li>Error Handling: Handle unexpected disconnects gracefully.</li> <li>Clients: Implement reconnection and state recovery.</li> </ul>"},{"location":"websockets/integrations/django-channels/","title":"Django Channels","text":""},{"location":"websockets/integrations/django-channels/#integrating-websockets-with-django-channels","title":"Integrating WebSockets with Django Channels","text":"<p>Django Channels extends Django to handle WebSockets, long-poll HTTP, and other asynchronous protocols, enabling real-time features in Django apps.</p> <p>This guide covers basic setup, routing, consumers, and best practices for WebSocket support using Django Channels.</p>"},{"location":"websockets/integrations/django-channels/#1-installation","title":"\ud83d\ude80 1. Installation","text":"<p>Install Django Channels and its dependencies:</p> <pre><code>pip install channels\n</code></pre> <p>Add Channels to your <code>INSTALLED_APPS</code> in <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    \"channels\",\n]\n</code></pre> <p>Set the ASGI application:</p> <pre><code>ASGI_APPLICATION = \"your_project.asgi.application\"\n</code></pre>"},{"location":"websockets/integrations/django-channels/#2-asgi-configuration","title":"\ud83c\udfd7 2. ASGI Configuration","text":"<p>Create or update <code>asgi.py</code> to include Channels routing:</p> <pre><code>import os\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom django.core.asgi import get_asgi_application\nfrom channels.auth import AuthMiddlewareStack\nimport your_app.routing\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"your_project.settings\")\n\napplication = ProtocolTypeRouter({\n    \"http\": get_asgi_application(),\n    \"websocket\": AuthMiddlewareStack(\n        URLRouter(\n            your_app.routing.websocket_urlpatterns\n        )\n    ),\n})\n</code></pre>"},{"location":"websockets/integrations/django-channels/#3-routing","title":"\ud83d\udce1 3. Routing","text":"<p>Create a <code>routing.py</code> file in your Django app:</p> <pre><code>from django.urls import re_path\nfrom . import consumers\n\nwebsocket_urlpatterns = [\n    re_path(r\"ws/chat/(?P&lt;room_name&gt;\\w+)/$\", consumers.ChatConsumer.as_asgi()),\n]\n</code></pre>"},{"location":"websockets/integrations/django-channels/#4-creating-a-consumer","title":"\ud83d\udee0 4. Creating a Consumer","text":"<p>Consumers handle WebSocket connections similar to Django views.</p> <p>Example <code>consumers.py</code>:</p> <pre><code>import json\nfrom channels.generic.websocket import AsyncWebsocketConsumer\n\nclass ChatConsumer(AsyncWebsocketConsumer):\n    async def connect(self):\n        self.room_name = self.scope[\"url_route\"][\"kwargs\"][\"room_name\"]\n        self.room_group_name = f\"chat_{self.room_name}\"\n\n        # Join room group\n        await self.channel_layer.group_add(\n            self.room_group_name,\n            self.channel_name,\n        )\n        await self.accept()\n\n    async def disconnect(self, close_code):\n        # Leave room group\n        await self.channel_layer.group_discard(\n            self.room_group_name,\n            self.channel_name,\n        )\n\n    # Receive message from WebSocket\n    async def receive(self, text_data):\n        text_data_json = json.loads(text_data)\n        message = text_data_json.get(\"message\")\n\n        # Broadcast message to group\n        await self.channel_layer.group_send(\n            self.room_group_name,\n            {\n                \"type\": \"chat_message\",\n                \"message\": message,\n            },\n        )\n\n    # Receive message from group\n    async def chat_message(self, event):\n        message = event[\"message\"]\n\n        # Send message to WebSocket\n        await self.send(text_data=json.dumps({\"message\": message}))\n</code></pre>"},{"location":"websockets/integrations/django-channels/#5-authentication-permissions","title":"\ud83d\udd10 5. Authentication &amp; Permissions","text":"<p>Use Django\u2019s standard authentication system. Channels provides <code>AuthMiddlewareStack</code> to populate <code>scope[\"user\"]</code> with the authenticated user.</p> <p>Check authentication inside the consumer:</p> <pre><code>async def connect(self):\n    if self.scope[\"user\"].is_anonymous:\n        await self.close()\n    else:\n        await self.accept()\n</code></pre>"},{"location":"websockets/integrations/django-channels/#6-best-practices","title":"\u26a0\ufe0f 6. Best Practices","text":"<ul> <li>Use groups to broadcast messages efficiently.</li> <li>Handle disconnects to clean up resources.</li> <li>Avoid blocking code; use async features fully.</li> <li>Use Channels layers like Redis for multi-instance support.</li> <li>Sanitize and validate incoming messages.</li> </ul>"},{"location":"websockets/integrations/django-channels/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>FastAPI Integration: Alternative async backend.</li> <li>Message Format: Consistent message structure.</li> <li>Error Handling: Managing errors in consumers.</li> </ul>"},{"location":"websockets/integrations/fastapi-websocket/","title":"FastAPI","text":""},{"location":"websockets/integrations/fastapi-websocket/#integrating-websockets-with-fastapi","title":"Integrating WebSockets with FastAPI","text":"<p>FastAPI offers excellent built-in support for WebSockets, allowing you to build real-time features easily alongside your REST APIs.</p> <p>This guide covers the basics of setting up WebSocket endpoints, handling connections, sending/receiving messages, and best practices.</p>"},{"location":"websockets/integrations/fastapi-websocket/#1-setting-up-a-websocket-endpoint","title":"\ud83d\ude80 1. Setting Up a WebSocket Endpoint","text":"<p>Use FastAPI\u2019s <code>WebSocket</code> class and the <code>websocket</code> route decorator.</p> <pre><code>from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Message received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")\n</code></pre>"},{"location":"websockets/integrations/fastapi-websocket/#2-receiving-and-sending-messages","title":"\ud83d\udd04 2. Receiving and Sending Messages","text":"<ul> <li>Use <code>await websocket.receive_text()</code> or <code>await websocket.receive_json()</code> to receive.</li> <li>Use <code>await websocket.send_text()</code> or <code>await websocket.send_json()</code> to send.</li> </ul> <pre><code>data = await websocket.receive_json()\nawait websocket.send_json({\"type\": \"response\", \"data\": data})\n</code></pre>"},{"location":"websockets/integrations/fastapi-websocket/#3-handling-disconnects","title":"\u274c 3. Handling Disconnects","text":"<p>Catch <code>WebSocketDisconnect</code> exception to clean up or notify.</p> <pre><code>from fastapi import WebSocketDisconnect\n\ntry:\n    while True:\n        message = await websocket.receive_text()\n        # process message\nexcept WebSocketDisconnect:\n    print(\"Client disconnected\")\n</code></pre>"},{"location":"websockets/integrations/fastapi-websocket/#4-authentication","title":"\ud83d\udd10 4. Authentication","text":"<p>You can authenticate WebSocket connections by:</p> <ul> <li>Passing tokens as query parameters.</li> <li>Sending an auth message after connection.</li> </ul> Example<pre><code>@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket, token: str = None):\n    await websocket.accept()\n    if token != \"expected_token\":\n        await websocket.close(code=1008)\n        return\n    # Continue handling connection\n</code></pre>"},{"location":"websockets/integrations/fastapi-websocket/#5-managing-multiple-connections","title":"\ud83d\udce6 5. Managing Multiple Connections","text":"<p>Use a connection manager to keep track of active clients, broadcast messages, or send to specific users.</p> <pre><code>class ConnectionManager:\n    def __init__(self):\n        self.active_connections: list[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def send_personal_message(self, message: str, websocket: WebSocket):\n        await websocket.send_text(message)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n</code></pre>"},{"location":"websockets/integrations/fastapi-websocket/#6-best-practices","title":"\u26a0\ufe0f 6. Best Practices","text":"<ul> <li>Always accept connections before receiving.</li> <li>Handle disconnects cleanly.</li> <li>Authenticate early and close unauthorized connections.</li> <li>Use background tasks or queues for heavy processing.</li> <li>Use <code>try/except</code> to prevent unhandled exceptions.</li> </ul>"},{"location":"websockets/integrations/fastapi-websocket/#next-steps","title":"\ud83d\udd1a Next Steps","text":"<ul> <li>Message Format: Use a consistent message envelope.</li> <li>Authentication: Secure your WebSocket sessions.</li> <li>Error Handling: Gracefully handle errors.</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""}]}