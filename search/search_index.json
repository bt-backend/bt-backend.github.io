{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Back of my mind","text":"<p>Icons8: Free Icon</p> <pre><code>my-backend-docs/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md                # Home page\n\u2502   \u251c\u2500\u2500 installation.md         # Installation guide\n\u2502   \u251c\u2500\u2500 setup.md                # Setup instructions\n\u2502   \u251c\u2500\u2500 architecture.md         # System architecture overview\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # API overview\n\u2502   \u2502   \u251c\u2500\u2500 authentication.md   # Authentication &amp; Authorization\n\u2502   \u2502   \u251c\u2500\u2500 endpoints.md        # List of API endpoints\n\u2502   \u2502   \u251c\u2500\u2500 rate-limiting.md    # Rate limiting and throttling\n\u2502   \u2502   \u251c\u2500\u2500 error-handling.md   # Error handling and response codes\n\u2502   \u251c\u2500\u2500 database/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Database overview\n\u2502   \u2502   \u251c\u2500\u2500 schema.md           # Database schema\n\u2502   \u2502   \u251c\u2500\u2500 migrations.md       # Migration guide\n\u2502   \u2502   \u251c\u2500\u2500 relationships.md    # Entity relationships (ERD)\n\u2502   \u251c\u2500\u2500 testing/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Testing overview\n\u2502   \u2502   \u251c\u2500\u2500 unit-testing.md     # Unit testing guidelines\n\u2502   \u2502   \u251c\u2500\u2500 integration-testing.md  # Integration testing setup\n\u2502   \u2502   \u251c\u2500\u2500 test-coverage.md    # Test coverage report\n\u2502   \u251c\u2500\u2500 deployment/\n\u2502   \u2502   \u251c\u2500\u2500 index.md            # Deployment guide\n\u2502   \u2502   \u251c\u2500\u2500 ci-cd.md            # CI/CD setup\n\u2502   \u2502   \u251c\u2500\u2500 docker.md           # Docker setup\n\u2502   \u251c\u2500\u2500 troubleshooting.md      # Common issues and solutions\n\u2502   \u251c\u2500\u2500 best-practices.md       # Backend best practices (security, scalability, etc.)\n\u2502   \u251c\u2500\u2500 glossary.md             # Glossary of terms\n\u251c\u2500\u2500 mkdocs.yml                  # MkDocs configuration file\n</code></pre>"},{"location":"#should-you-learn-nodejs-before-express","title":"Should You Learn Node.js Before Express?","text":"<p>Yes, it's recommended to learn <code>Node.js</code> first before diving into <code>Express.js</code>. Here\u2019s why:</p> <ol> <li> <p>Node.js is the foundation:</p> <ul> <li> <p>Express is a web framework built on top of Node.js, so understanding how Node works will make it much easier to understand how Express fits into the picture.</p> </li> <li> <p>Node.js provides the JavaScript runtime on the server, handling things like file I/O, HTTP requests, and event-driven programming. Express abstracts much of this functionality and makes it easier to work with, but if you don\u2019t understand the basics of Node, you might feel lost when things go wrong.</p> </li> </ul> </li> <li> <p>Understanding Node Basics: Before you jump into Express, make sure you understand:</p> <ul> <li>How to use Node.js modules (like <code>fs</code>, <code>http</code>, <code>path</code>).</li> <li>The event-driven architecture and how Node uses a single-threaded model for non-blocking I/O.</li> <li>How to create HTTP servers and handle requests and responses in pure Node.js (without Express).</li> <li>How npm (Node Package Manager) works for managing dependencies.</li> </ul> </li> <li> <p>Express Simplifies Node:</p> <ul> <li>Express is built on top of Node and provides a simplified API for handling HTTP requests, routing, middleware, and so on. It does a lot of the heavy lifting for you, making Node development easier and faster. However, if you don\u2019t know the underlying concepts of Node.js, you might not fully appreciate how Express is working under the hood.</li> </ul> </li> </ol> Suggested Learning Order <ol> <li> <p>Learn Node.js basics first:</p> <ul> <li>Understand Event Loop, callbacks, promises, and async/await.</li> <li>Learn how to create simple web servers using the built-in <code>http</code> module.</li> <li>Explore how to handle file operations, work with the file system (<code>fs</code>), and make network requests (using <code>http</code>, <code>https</code> modules).</li> </ul> </li> <li> <p>Learn Express.js:</p> <ul> <li>Once you're comfortable with Node.js, you can jump into Express. You\u2019ll see how Express simplifies the HTTP server creation process, helps with routing, middleware handling, and provides utilities for common backend tasks.</li> </ul> </li> </ol> <p>Example: Node.js vs Express</p> <p>Let\u2019s compare writing a basic web server in Node.js versus Express:</p> <p>Node.js (Barebones HTTP Server):</p> <pre><code>const http = require(\"http\");\n\nconst server = http.createServer((req, res) =&gt; {\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"text/plain\");\n  res.end(\"Hello, world!\");\n});\n\nserver.listen(3000, \"127.0.0.1\", () =&gt; {\n  console.log(\"Server running at http://127.0.0.1:3000/\");\n});\n</code></pre> <p>Express (Same Server):</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.get(\"/\", (req, res) =&gt; {\n  res.send(\"Hello, world!\");\n});\n\napp.listen(3000, () =&gt; {\n  console.log(\"Server running at http://localhost:3000\");\n});\n</code></pre> <p>With Express, you don\u2019t need to manually set up headers, status codes, or handle the routing manually. Express makes it much simpler to write server code, especially for larger applications.</p> <p>In Summary:</p> <ul> <li>Learn Node.js first: It\u2019s the foundational knowledge that will help you understand how Express works. You\u2019ll get a better grasp of the underlying JavaScript and asynchronous programming concepts.</li> <li>Learn Express afterward: Express simplifies common tasks in Node.js, like routing and middleware, and it makes backend development faster and more structured.</li> </ul>"},{"location":"api/","title":"API overview","text":""},{"location":"api/authentication/","title":"Authentication &amp; Authorization","text":""},{"location":"api/endpoints/","title":"List of API endpoints","text":""},{"location":"api/error-handling/","title":"Error handling and response codes","text":""},{"location":"api/rate-limiting/","title":"Rate limiting and throttling","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"core/architecture/","title":"System Architecture Overview","text":"<p>This section outlines the high-level architecture of the backend system. The backend is designed to be scalable, maintainable, and secure, supporting a variety of use cases while ensuring flexibility and performance.</p>"},{"location":"core/architecture/#architecture-diagram","title":"Architecture Diagram","text":"<p>Note: Replace with your actual architecture diagram.</p>"},{"location":"core/architecture/#components","title":"Components","text":""},{"location":"core/architecture/#1-client-frontend","title":"1. Client (Frontend)","text":"<p>The client-side (browser, mobile app, or other service) communicates with the backend via a RESTful API or GraphQL (depending on the use case). The client handles the user interface and interaction, sending requests to the backend for data and receiving responses to update the UI.</p>"},{"location":"core/architecture/#2-api-gateway","title":"2. API Gateway","text":"<p>The API Gateway acts as the entry point for all incoming requests from the client. It handles routing, authentication, rate-limiting, and sometimes caching of requests to backend services. It may also handle load balancing if multiple backend services are deployed.</p> <p>Responsibilities:</p> <ul> <li>Authenticate and authorize requests.</li> <li>Route requests to the appropriate backend service.</li> <li>Perform rate-limiting and security checks.</li> </ul>"},{"location":"core/architecture/#3-authentication-authorization-service","title":"3. Authentication &amp; Authorization Service","text":"<p>This service manages user authentication, session management, and authorization. It verifies the identity of users and generates JWT tokens or OAuth tokens for secure communication between the client and backend.</p> <p>Responsibilities:</p> <ul> <li>Authenticate users (login, logout).</li> <li>Issue and verify tokens (JWT, OAuth).</li> <li>Provide user roles and permissions.</li> </ul>"},{"location":"core/architecture/#4-core-backend-services","title":"4. Core Backend Services","text":"<p>These are the core services that handle business logic, data processing, and serve API requests. The backend is typically divided into different services, each responsible for a specific set of operations (e.g., user management, product management, payment processing, etc.).</p> <p>Service Layer:</p> <ul> <li>Each backend service can be either monolithic or microservices-based.</li> <li>Microservices may interact with each other via REST or gRPC.</li> <li>The services are stateless and can be scaled independently.</li> </ul>"},{"location":"core/architecture/#5-database-layer","title":"5. Database Layer","text":"<p>The database stores all persistent data, such as user information, transactional data, and application state. The choice of database may vary depending on the project needs.</p> <p>Relational Database (SQL) Example:</p> <ul> <li>PostgreSQL, MySQL, or similar.</li> <li>Stores structured data with relationships between entities (e.g., users, products).</li> </ul> <p>NoSQL Database Example:</p> <ul> <li>MongoDB, Redis, etc., for flexible schema or caching purposes.</li> </ul> <p>Responsibilities:</p> <ul> <li>Handle CRUD operations for entities.</li> <li>Manage relationships and schema consistency.</li> <li>Ensure data integrity and durability.</li> </ul>"},{"location":"core/architecture/#6-caching-layer","title":"6. Caching Layer","text":"<p>Caching is used to store frequently accessed data in-memory to reduce database load and speed up response times. Common tools include Redis or Memcached.</p> <p>Responsibilities:</p> <ul> <li>Cache common query results (e.g., product data, user sessions).</li> <li>Improve read performance by reducing database load.</li> </ul>"},{"location":"core/architecture/#7-queuemessage-broker","title":"7. Queue/Message Broker","text":"<p>In a microservices or distributed architecture, a message queue or broker (e.g., RabbitMQ, Kafka) facilitates asynchronous communication between services, decoupling the services and enabling event-driven architecture.</p> <p>Responsibilities:</p> <ul> <li>Process long-running tasks asynchronously (e.g., email notifications, image processing).</li> <li>Ensure services are loosely coupled and resilient.</li> </ul>"},{"location":"core/architecture/#8-monitoring-and-logging","title":"8. Monitoring and Logging","text":"<p>Monitoring tools (e.g., Prometheus, Grafana) and centralized logging systems (e.g., ELK Stack, Splunk) are essential for tracking the performance, availability, and errors in the backend system.</p> <p>Responsibilities:</p> <ul> <li>Collect metrics on request latency, error rates, and system health.</li> <li>Aggregate logs for debugging and auditing.</li> <li>Send alerts for abnormal system behavior.</li> </ul>"},{"location":"core/architecture/#9-cicd-pipeline","title":"9. CI/CD Pipeline","text":"<p>Continuous Integration and Continuous Deployment (CI/CD) automates the build, testing, and deployment process. Tools like Jenkins, GitLab CI, or GitHub Actions ensure that code changes are automatically tested and deployed to production with minimal human intervention.</p> <p>Responsibilities:</p> <ul> <li>Automate code quality checks (linting, unit tests).</li> <li>Deploy to staging and production environments.</li> <li>Rollback deployments if issues occur.</li> </ul>"},{"location":"core/architecture/#deployment-architecture","title":"Deployment Architecture","text":""},{"location":"core/architecture/#1-containerization-docker","title":"1. Containerization (Docker)","text":"<p>The backend services are containerized using Docker to ensure consistent environments across development, staging, and production. This also simplifies scaling and deployment.</p>"},{"location":"core/architecture/#2-orchestration-kubernetes","title":"2. Orchestration (Kubernetes)","text":"<p>Kubernetes is used for orchestrating and managing containerized services. It provides features like auto-scaling, self-healing, and load balancing.</p>"},{"location":"core/architecture/#3-cloud-infrastructure-aws-gcp-azure","title":"3. Cloud Infrastructure (AWS, GCP, Azure)","text":"<p>The backend is deployed on cloud infrastructure to provide scalability, redundancy, and high availability. The cloud provider may offer additional services like managed databases, caching, and message queues.</p> <p>Responsibilities:</p> <ul> <li>Automate scaling based on traffic load.</li> <li>Ensure fault tolerance and disaster recovery.</li> </ul>"},{"location":"core/architecture/#summary","title":"Summary","text":"<p>The backend architecture is designed for scalability, resilience, and performance. By splitting the system into manageable components and services, we ensure that each part of the system can be developed, tested, and deployed independently. This architecture is adaptable to various backend frameworks and technologies, and it supports a wide range of client applications.</p> <p>For detailed specifications of each component, see the corresponding documentation sections:</p> <ul> <li>API Documentation</li> <li>Database Schema</li> <li>Deployment Guide</li> </ul>"},{"location":"core/bff/intro/","title":"Intro","text":"<p>The Backends for Frontends (BFF) pattern is an architectural pattern that involves creating a separate backend service for each frontend application. This pattern is often used in microservices architectures, where each service is responsible for a specific function.</p> <p></p> <p></p>"},{"location":"core/bff/intro/#what-is-backend-for-frontend-bff","title":"What is Backend for Frontend (BFF)?","text":"<p>Backend for Frontend (BFF) is a design pattern that involves creating a dedicated backend service tailored specifically for a particular frontend application (like a web or mobile app). This approach helps in optimizing the communication between the frontend and backend by providing a layer that is specifically designed to serve the needs of the frontend, making it easier to manage and improve performance.</p>"},{"location":"core/bff/intro/#overview","title":"Overview","text":"<p>Backend for Frontend (BFF) is designed to create a dedicated backend layer tailored specifically for individual frontend applications. It serves to optimize communication, improve performance, and streamline development by providing APIs that are custom-built to meet the specific needs of each frontend.</p>"},{"location":"core/bff/intro/#key-features-of-bff","title":"Key Features of BFF","text":"<ol> <li>Tailored API: Each frontend (web, mobile, etc.) can have its own backend that serves only the data and functionality it needs.</li> <li>Reduced Over-fetching: By designing the API specifically for the frontend, you can avoid sending unnecessary data, reducing payload sizes.</li> <li>Simplified Logic: It allows for frontend-specific logic to reside in the backend, keeping the frontend code cleaner and more focused on presentation.</li> <li>Easier Adaptation: Changes in the frontend can often be accommodated in the BFF without affecting the overall backend architecture.</li> </ol>"},{"location":"core/bff/intro/#scenario","title":"Scenario","text":"With BFFWithout BFFSummary <p>Suppose you have two different frontend applications: a web app and a mobile app. Each of these apps requires different data formats and structures from the backend.</p> <ul> <li>Web App: Needs detailed information, including user profiles, order histories, and recommendations.</li> <li>Mobile App: Needs summarized data to save bandwidth, focusing only on essential information like user profiles and recent orders.</li> </ul> BFF Implementation <p>BFF Layer:</p> <ul> <li> <p>Web BFF:</p> <ul> <li>API Endpoint: <code>/api/web/user-profile</code></li> <li>Returns detailed user information, including nested objects.</li> </ul> </li> <li> <p>Mobile BFF:</p> <ul> <li>API Endpoint: <code>/api/mobile/user-profile</code></li> <li>Returns a simplified version of the user profile with only essential fields.</li> </ul> </li> </ul> <p>Benefits:</p> <ul> <li>Tailored Responses: Each frontend gets exactly what it needs without over-fetching or under-fetching data.</li> <li>Decoupled Development: Frontend teams can work independently from backend teams since the BFF layer abstracts the backend complexities.</li> <li>Optimized Performance: By reducing payload sizes for the mobile app, you improve loading times and user experience.</li> </ul> <p>In a traditional setup, you might have a single backend service that serves both the web and mobile apps.</p> <ul> <li> <p>Single API Endpoint: <code>/api/user-profile</code></p> <ul> <li>Returns all user data regardless of the frontend requesting it, including detailed information that the mobile app doesn't need.</li> </ul> </li> </ul> Drawbacks: <ul> <li>Over-fetching: The mobile app receives more data than it needs, leading to larger payloads and slower response times.</li> <li>Inflexibility: Any changes required for one frontend can inadvertently affect the other, making development less agile.</li> <li>Complexity: Frontend developers may need to implement additional logic to filter and process unnecessary data, adding to their workload.</li> </ul> <p>Using a BFF allows you to tailor backend services specifically for different frontend applications, optimizing data delivery, improving performance, and simplifying development. In contrast, a traditional single-backend approach can lead to inefficiencies and complexities as frontends evolve.</p>"},{"location":"core/bff/intro/#implementation-in-drf","title":"Implementation in drf","text":""},{"location":"core/bff/intro/#is-bff-a-microservice","title":"Is BFF a Microservice?","text":"<p>Yes, the Backend For Frontend pattern is one of several types of microservice architecture patterns.</p> <p>Each BFF service is considered a microservice that serves as a connector between frontend and backend development.</p>"},{"location":"core/bff/intro/#reference","title":"Reference","text":"<ul> <li>Backend for Frontend: Understanding the Pattern to Unlock Its Power</li> <li>Backends for Frontends (BFF) Pattern: Architectural Patterns</li> <li>Why \u201cBackend For Frontend\u201d Application Architecture?</li> <li>Backends For Frontends \u2014 My Take</li> </ul>"},{"location":"core/bff/question/","title":"Question","text":""},{"location":"core/bff/question/#question","title":"Question","text":"<p>What is required to implement a Backend for Frontend (BFF) architecture in Django with Django REST Framework (DRF)?</p> <p>To implement a BFF architecture in Django and DRF, you generally need to focus on the following key components:</p> <ol> <li> <p>Custom Serializers:</p> <ul> <li>You will need to create different serializers for each frontend application (e.g., web and mobile) to tailor the data structure according to their specific needs.</li> </ul> </li> <li> <p>Viewsets:</p> <ul> <li>Create separate viewsets for each frontend, using the custom serializers to handle requests and responses appropriately.</li> </ul> </li> <li> <p>URLs:</p> <ul> <li>Set up distinct URL routes for each BFF endpoint, ensuring that each frontend can access its corresponding API.</li> </ul> </li> <li> <p>Data Models (if applicable):</p> <ul> <li>Your data models may remain the same, but the way you serve them will differ based on the serializers and viewsets you create.</li> </ul> </li> <li> <p>Authentication and Permissions (if needed):</p> <ul> <li>You may also want to implement different authentication or permission schemes based on the frontend requirements.</li> </ul> </li> </ol> <p>Summary</p> <p>While customizing serializers is a significant part of implementing a BFF, it\u2019s not the only step. You also need to create dedicated viewsets and URL configurations to ensure each frontend receives the data in the format it requires.</p>"},{"location":"core/bff/question/#step-by-step-example","title":"Step-by-Step Example","text":"Basic Example <ol> <li> <p>Set Up Your Django Project</p> <p>First, create a new Django project and an app:</p> <pre><code>django-admin startproject my_bff\ncd my_bff\ndjango-admin startapp user\n</code></pre> </li> <li> <p>Install Django REST Framework</p> <p>Install DRF:</p> <pre><code>pip install djangorestframework\n</code></pre> <p>Add <code>'rest_framework'</code> and your app (<code>'user'</code>) to <code>INSTALLED_APPS</code> in <code>settings.py</code>:</p> <pre><code># my_bff/settings.py\n\nINSTALLED_APPS = [\n    ...\n    'rest_framework',\n    'user',\n]\n</code></pre> </li> <li> <p>Create the User Model</p> <p>Define a simple User model in <code>models.py</code>:</p> <pre><code># user/models.py\n\nfrom django.db import models\n\nclass User(models.Model):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    phone = models.CharField(max_length=15)\n    street = models.CharField(max_length=255)\n    city = models.CharField(max_length=100)\n    zipcode = models.CharField(max_length=10)\n    newsletter = models.BooleanField(default=False)\n    notifications = models.BooleanField(default=False)\n\n    def __str__(self):\n        return self.username\n</code></pre> <p>Run the migrations to create the User table:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> </li> <li> <p>Create Serializers</p> <p>Create serializers for the User model in <code>serializers.py</code>:</p> <pre><code># user/serializers.py\n\nfrom rest_framework import serializers\nfrom .models import User\n\nclass UserProfileWebSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email', 'phone', 'street', 'city', 'zipcode', 'newsletter', 'notifications']\n\nclass UserProfileMobileSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email']\n</code></pre> </li> <li> <p>Create Viewsets</p> <p>Define viewsets for the different BFFs in <code>views.py</code>:</p> <pre><code># user/views.py\n\nfrom rest_framework import viewsets\nfrom .models import User\nfrom .serializers import UserProfileWebSerializer, UserProfileMobileSerializer\n\nclass UserProfileWebViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserProfileWebSerializer\n\nclass UserProfileMobileViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserProfileMobileSerializer\n</code></pre> </li> <li> <p>Configure URLs</p> <p>Set up URLs for the two different BFFs in <code>urls.py</code>:</p> <pre><code># user/urls.py\n\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import UserProfileWebViewSet, UserProfileMobileViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'web/user-profile', UserProfileWebViewSet, basename='user-web')\nrouter.register(r'mobile/user-profile', UserProfileMobileViewSet, basename='user-mobile')\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre> <p>Include the user app URLs in the main project <code>urls.py</code>:</p> <pre><code># my_bff/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('api/', include('user.urls')),\n]\n</code></pre> </li> <li> <p>Test the BFF APIs</p> <p>Run your Django server:</p> <pre><code>python manage.py runserver\n</code></pre> </li> </ol>"},{"location":"core/bff/question/#endpoint","title":"Endpoint","text":"<p>Now, you can test the endpoints using a tool like <code>Postman</code> or <code>curl</code>.</p> 1. Web App Endpoint:2. Mobile App Endpoint: <ul> <li>URL: <code>http://localhost:8000/api/web/user-profile/</code></li> <li> <p>Response Example:</p> <pre><code>{\n    \"id\": 1,\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\",\n    \"phone\": \"123-456-7890\",\n    \"street\": \"123 Elm St\",\n    \"city\": \"Somewhere\",\n    \"zipcode\": \"12345\",\n    \"newsletter\": true,\n    \"notifications\": false\n}\n</code></pre> </li> </ul> <ul> <li>URL: <code>http://localhost:8000/api/mobile/user-profile/</code></li> <li> <p>Response Example:</p> <pre><code>{\n    \"id\": 1,\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\"\n}\n</code></pre> </li> </ul> Benefits of Using BFF <ol> <li> <p>Tailored Responses:</p> <ul> <li>The web app receives all necessary details, while the mobile app only gets the crucial information it needs.</li> </ul> </li> <li> <p>Reduced Payload:</p> <ul> <li>The mobile app's response is smaller, improving load times and performance.</li> </ul> </li> <li> <p>Decoupled Development:</p> <ul> <li>Frontend teams can make changes to their BFFs independently without affecting the other frontend.</li> </ul> </li> </ol> <p>Conclusion</p> <p>In this example, we implemented a BFF architecture using Django and Django REST Framework. We created two separate APIs tailored for different frontends (web and mobile), showcasing how to customize serializers, viewsets, and URLs to meet the specific needs of each frontend application. This approach optimizes data delivery and enhances performance, making it a great architectural choice.</p>"},{"location":"database/","title":"Overview","text":"<p>api</p>"},{"location":"database/migrations/","title":"Migration guide","text":""},{"location":"database/relationships/","title":"Entity relationships (ERD)","text":""},{"location":"database/schema/","title":"Database schema","text":""},{"location":"deployment/","title":"Overview","text":"<p>api</p>"},{"location":"deployment/ci-cd/","title":"CI/CD setup","text":""},{"location":"deployment/docker/","title":"Docker setup","text":""},{"location":"framework/nodejs/guide/","title":"Guide","text":""},{"location":"framework/nodejs/guide/#tech-stack","title":"Tech Stack","text":"<p>For this simple CRUD API, the recommended tech stack is:</p> <ol> <li> <p>Backend Framework: Node.js with Express.js</p> <p>Lightweight and easy to use for building REST APIs.</p> </li> <li> <p>Database: PostgreSQL</p> <p>Structured and relational, ideal for handling amount and date data.</p> </li> <li> <p>ORM: Sequelize</p> <p>Simplifies database interactions with PostgreSQL.</p> </li> <li> <p>ontainerization: Docker</p> <p>Ensures portability and ease of deployment.</p> </li> </ol>"},{"location":"framework/nodejs/guide/#folder-structure-backend-only","title":"Folder Structure (Backend Only)","text":"<p>In this setup, you will have a backend-only project that exposes the API, and the React frontend (which will be in a separate project) will consume these APIs.</p> <pre><code>/my-app\n  /server                  # Backend (Node.js with Express and MongoDB)\n    /controllers           # API endpoint controllers\n    /models                # Mongoose models\n    /routes                # API routes\n    /config                # Database configuration\n    server.js              # Main entry point of the backend server\n    package.json           # Backend dependencies\n    .env                   # Environment variables (e.g., MongoDB URI)\n  README.md                # Project description\n</code></pre> <pre><code>- src/\n  - models/\n    - record.model.js\n  - routes/\n    - record.routes.js\n  - controllers/\n    - record.controller.js\n  - config/\n    - db.config.js\n  - server.js\n- Dockerfile\n- docker-compose.yml\n</code></pre>"},{"location":"framework/nodejs/guide/#backend-setup","title":"Backend Setup","text":""},{"location":"framework/nodejs/guide/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Go to the backend directory (<code>/server</code>) and initialize the project with:</p> <pre><code>cd /server\nnpm init -y\nnpm install express mongoose cors dotenv\n</code></pre>"},{"location":"framework/nodejs/guide/#2-folder-structure-and-backend-code","title":"2. Folder Structure and Backend Code","text":"<ul> <li>server.js: Entry point for the Express server.</li> <li>controllers/recordController.js: Controller logic for CRUD operations.</li> <li>models/Record.js: Mongoose schema for records.</li> <li>routes/recordRoutes.js: Define API routes.</li> </ul>"},{"location":"framework/nodejs/guide/#7-running-the-backend","title":"7. Running the Backend","text":"<pre><code>node server.js\n</code></pre>"},{"location":"framework/nodejs/guide/#code","title":"CODE","text":"<ol> <li> <p>Database Configuration (<code>src/config/db.config.js</code>)</p> <pre><code>const { Sequelize } = require(\"sequelize\");\n\nconst sequelize = new Sequelize(\"crud_db\", \"postgres\", \"password\", {\n  host: \"localhost\",\n  dialect: \"postgres\",\n});\n\nmodule.exports = sequelize;\n</code></pre> </li> <li> <p>Model Definition (<code>src/models/record.model.js</code>)</p> <pre><code>const { DataTypes } = require(\"sequelize\");\nconst sequelize = require(\"../config/db.config\");\n\nconst Record = sequelize.define(\"Record\", {\n  amount: {\n    type: DataTypes.FLOAT,\n    allowNull: false,\n  },\n  date: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n});\n\nmodule.exports = Record;\n</code></pre> </li> <li> <p>Controller (<code>src/controllers/record.controller.js</code>)</p> <pre><code>const Record = require(\"../models/record.model\");\n\n// Create a new record\nexports.createRecord = async (req, res) =&gt; {\n  try {\n    const { amount, date } = req.body;\n    const record = await Record.create({ amount, date });\n    res.status(201).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Get all records\nexports.getRecords = async (req, res) =&gt; {\n  try {\n    const records = await Record.findAll();\n    res.status(200).json(records);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Get a single record by ID\nexports.getRecordById = async (req, res) =&gt; {\n  try {\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n    res.status(200).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Update a record by ID\nexports.updateRecord = async (req, res) =&gt; {\n  try {\n    const { amount, date } = req.body;\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n\n    record.amount = amount;\n    record.date = date;\n    await record.save();\n\n    res.status(200).json(record);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n\n// Delete a record by ID\nexports.deleteRecord = async (req, res) =&gt; {\n  try {\n    const record = await Record.findByPk(req.params.id);\n    if (!record)\n      return res.status(404).json({ message: \"Record not found\" });\n\n    await record.destroy();\n\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n};\n</code></pre> </li> <li> <p>Routes (<code>src/routes/record.routes.js</code>)</p> <pre><code>const express = require(\"express\");\nconst router = express.Router();\nconst controller = require(\"../controllers/record.controller\");\n\nrouter.post(\"/\", controller.createRecord);\nrouter.get(\"/\", controller.getRecords);\nrouter.get(\"/:id\", controller.getRecordById);\nrouter.put(\"/:id\", controller.updateRecord);\nrouter.delete(\"/:id\", controller.deleteRecord);\n\nmodule.exports = router;\n</code></pre> </li> <li> <p>Server Setup (<code>src/server.js</code>)</p> <pre><code>const express = require(\"express\");\nconst sequelize = require(\"./config/db.config\");\nconst recordRoutes = require(\"./routes/record.routes\");\n\nconst app = express();\napp.use(express.json());\n\n// Routes\napp.use(\"/api/records\", recordRoutes);\n\n// Start server and connect to DB\nsequelize\n  .sync()\n  .then(() =&gt; {\n    console.log(\"Database connected!\");\n    app.listen(3000, () =&gt; console.log(\"Server running on port 3000\"));\n  })\n  .catch((err) =&gt; console.error(\"Database connection failed:\", err));\n</code></pre> </li> <li> <p>Dockerfile</p> <pre><code>FROM node:16\n\nWORKDIR /app\n\nCOPY package.json package-lock.json ./\nRUN npm install\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [\"node\", \"src/server.js\"]\n</code></pre> </li> <li> <p>Docker Compose (<code>docker-compose.yml</code>)</p> <pre><code>version: \"3.8\"\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - db\n\n  db:\n    image: postgres:latest\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: crud_db\n    ports:\n      - \"5432:5432\"\n</code></pre> </li> </ol> How to Run <ol> <li> <p>Build and start the services:</p> <pre><code>docker-compose up --build\n</code></pre> </li> <li> <p>Access the API at <code>http://localhost:3000/api/records</code>.</p> </li> </ol> <p>This setup provides a fully functional CRUD API using Node.js, Express, PostgreSQL, Sequelize, and Docker</p>"},{"location":"framework/nodejs/guide/#extra","title":"Extra","text":""},{"location":"framework/nodejs/guide/#database","title":"DATABASE","text":"<pre><code>CREATE DATABASE testdb;\n\\list\n# or\n\\l\n# is same\n</code></pre>"},{"location":"framework/nodejs/guide/#listing-users-in-postgresql","title":"Listing users in PostgreSQL","text":"<p>Using the <code>\\du</code> Command</p> <ul> <li>The simplest way to list all users is by using the <code>\\du</code> command in the psql terminal.</li> <li>This will show a list of all roles in the database, including users, their attributes (such as superuser status), and their assigned roles.</li> </ul> <pre><code>\\du\n</code></pre> <p>This will display a table with the following columns:</p> <ul> <li>Role Name: The name of the user or role.</li> <li>Attributes: Whether the role is a superuser, can create databases, or has login privileges.</li> <li>Member Of: Any other roles this user belongs to.</li> </ul>"},{"location":"framework/nodejs/guide/#list-of-roles","title":"List of Roles","text":"Role name Attributes Member of postgres Superuser, Create role, Create DB, Replication, Bypass RLS {} bishow Create DB {} myuser Create DB {postgres}"},{"location":"framework/nodejs/guide/#to-check-if-user-has-password-or-not","title":"To Check if user has password or not","text":"<p>To check if a PostgreSQL user (like <code>bishow</code>) has a password set, you can query the pg_shadow system catalog table, which stores user information including the password hash (if set).</p> <ol> <li> <p>Querying the <code>pg_shadow</code> Table</p> <p>The <code>pg_shadow</code> table contains user information, including password data. To check if the user <code>bishow</code> has a password set, you can run the following query:</p> <pre><code>SELECT usename, passwd FROM pg_shadow WHERE usename = 'bishow';\n</code></pre> <ul> <li><code>usename</code>: The username.</li> <li><code>passwd</code>: The hashed password (if set) or an empty string if no password is set.</li> </ul> </li> </ol>"},{"location":"framework/nodejs/guide/#switch-user-to-login","title":"Switch User to Login","text":"<p>When you run the command:</p> <pre><code>sudo -u postgres psql\n</code></pre> <p>You are switching to the <code>postgres</code> user and logging into the PostgreSQL database as the <code>postgres</code> user (which is typically the superuser for PostgreSQL). Here's a breakdown:</p> <ul> <li> <p><code>sudo -u postgres</code>: This part of the command tells <code>sudo</code> to run the following command (<code>psql</code>) as the <code>postgres</code> user, which is usually the default superuser in PostgreSQL.</p> </li> <li> <p><code>psql</code>: This is the PostgreSQL interactive terminal that connects to the database.</p> </li> </ul> <p>Once you're inside the psql terminal, you'll be logged in as the <code>postgres</code> PostgreSQL user, not as your system's current user (e.g., <code>bishow</code> or any other user you might have logged in as on the operating system).</p> <p>To verify this inside the PostgreSQL terminal, you can run the following SQL command:</p> <pre><code>SELECT current_user;\n</code></pre> <p>This will return the PostgreSQL user you're currently logged in as.</p> <pre><code>postgres=# SELECT current_user;\n current_user\n--------------\n postgres\n(1 row)\n</code></pre> <p>In this example, the current PostgreSQL user is <code>postgres</code>.</p>"},{"location":"framework/nodejs/history/","title":"History","text":"<p>Node.js was initially developed by Ryan Dahl. He took the V8 JavaScript engine from Google\u2019s Chrome browser, added some APIs, wrapped it in an event loop, and launched it as an open-source product on Linux and macOS in 2009. The Windows edition arrived in 2011.</p> <p>The Node Package Manager (npm) was introduced in <code>2010</code>. It allowed developers to use code modules published by others in their own projects. There was no official ECMAScript module standard at the time, so Node.js and npm adopted CommonJS.</p> <p><code>Node.js: Novice to Ninja by SitePoint</code></p> <p>Node.js allows a developer with frontend JavaScript knowledge to leverage their skills on the backend.</p>"},{"location":"framework/nodejs/history/#node-version-manager","title":"Node Version Manager","text":"<p>Node Version Manager (nvm) is a tool that allows multiple editions of Node.js to be installed on the same Linux, macOS, or Windows WSL system. This can be practical if you\u2019re working on two or more projects using different versions of Node.js</p>"},{"location":"framework/nodejs/history/#choosing-a-nodejs-version","title":"Choosing a Node.js Version","text":"<p>Install a recent release of Node.js unless you\u2019re supporting a legacy application with specific requirements.</p> <p>Even-numbered Node.js versions \u2014 such as <code>16</code>, <code>18</code>, and <code>20</code> \u2014 focus on stability and security with long-term support (LTS). Updates are provided for at least two years, so I recommend them for live production servers. You should install an identical version on your development machine.</p> <p>Odd-numbered versions \u2014 such as <code>15</code>, <code>17</code>, <code>19</code> \u2014 are under active development and may have experimental features. They\u2019re fine for development if you\u2019re learning, experimenting, or upgrading frequently.</p>"},{"location":"framework/nodejs/overview/","title":"Overview","text":"<p>Node.js is a JavaScript runtime, which means it runs programs written in JavaScript. (1)</p> <ol> <li> Node.js: Novice to Ninja by SitePoint</li> </ol> <p>Node.js\u2014JavaScript code execution environment outside the browser. This platform allows you to write server-side code for dynamic web pages and web applications, as well as for command-line programs. (1)</p> <ol> <li> <code>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr, pg-11</code>. Using Node.js implements the \u201cJavaScript for everything\u201d paradigm. It involves using a single programming language to develop web applications instead of using different languages to work on the frontend and backend. Node.js is a server platform for working with JavaScript through the V8 engine.</li> </ol> <p>Node.js is very closely related to JavaScript, the syntax and architectural approaches are identical, only the \u201cbindings\u201d (browser and server) differ. (1)</p> <ol> <li> <code>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr, pg-33</code>.</li> </ol>"},{"location":"framework/nodejs/overview/#main-features-of-nodejs","title":"Main Features of Node.js","text":"<ul> <li>Speed</li> <li>Simplicity</li> <li>JavaScript</li> <li>V8 Engine</li> <li>Asynchrony</li> <li>Libraries</li> </ul>"},{"location":"framework/nodejs/overview/#best-use-cases","title":"Best Use Cases","text":"<ol> <li>Real-time applications:</li> <li>Low learning curve:</li> <li>Performance and scalability:</li> <li>NPM support with rich modules:</li> <li>A useful unified code base:</li> <li>Data streaming:</li> <li>Well suited for creating microservices:</li> <li>Strong corporate support:</li> </ol>"},{"location":"framework/nodejs/overview/#books","title":"Books","text":"<ul> <li>Getting the Most out of Node.js Frameworks by Sufyan bin Uzayr</li> </ul>"},{"location":"testing/","title":"Overview","text":"<p>api</p>"},{"location":"testing/integration-testing/","title":"Integration testing setup","text":""},{"location":"testing/test-coverage/","title":"Test coverage report","text":""},{"location":"testing/unit-testing/","title":"Unit testing guidelines","text":""},{"location":"tools/overview/","title":"Backend Tools","text":""}]}